/*
Copyright 2024 The Alibaba Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package rollalgorithm

import (
	"github.com/spf13/pflag"
	app "k8s.io/api/apps/v1"
)

var (
	defaultRollingStrategy         = RollingStrategyLessFirst
	scaleOutWithLatestVersionCount = false
	maxUnavailableOldFirstStrategy = 30
)

// InitFlags InitFlags
func InitFlags(flagset *pflag.FlagSet) {
	flagset.StringVar(&defaultRollingStrategy, "default-rolling-strategy", defaultRollingStrategy, "rolling strategy define the strategy to select replica to update")
	flagset.BoolVar(&scaleOutWithLatestVersionCount, "scale-out-latest-version-node", scaleOutWithLatestVersionCount, "scale out with latest version node")
	flagset.IntVar(&maxUnavailableOldFirstStrategy, "max-unavailable-oldfirst-strategy", maxUnavailableOldFirstStrategy, "max unavailable for oldFirst rolling strategy, can't use oldFirst rolling strategy if bigger than this")
}

// CarryStrategyType  CarryStrategyType
type CarryStrategyType string

// CarryStrategyTypes
const (
	CeilCarryStrategyType  CarryStrategyType = "Ceil"
	FloorCarryStrategyType CarryStrategyType = "Floor"
)

// RollingStrategy
const (
	RollingStrategyOldFirst    = "oldFirst"
	RollingStrategyLatestFirst = "latestFirst"
	RollingStrategyLessFirst   = "lessFirst"
)

// ScheduleType
const (
	SchedulerTypeRolling = "rollingScheduler"
)

// SchedulePlan  is the spec for a SchedulePlan resource
type SchedulePlan struct {
	//Replicas 目标总数， 不能为nil
	Replicas *int32 `json:"replicas"`
	//依赖级别，是否依赖其它role，数值越大依赖越深，
	DependencyLevel *int32 `json:"dependencyLevel"`
	// The rollingset strategy to use to replace existing replica with new ones.
	// +optional
	// +patchStrategy=retainKeys
	Strategy        app.DeploymentStrategy `json:"strategy,omitempty"`
	RollingStrategy string                 `json:"rollingStrategy,omitempty"`
	// The percent of new Replicas. should be 0 - 100
	// Defaults to 100.
	// +optional
	LatestVersionRatio       *int32 `json:"latestVersionRatio,omitempty"`
	PaddedLatestVersionRatio *int32 `json:"paddedLatestVersionRatio,omitempty"`

	// +optional
	LatestVersionCarryStrategy CarryStrategyType `json:"latestVersionCarryStrategy,omitempty"`

	// Indicates that the rollingset is paused.
	// +optional
	Paused bool `json:"paused,omitempty"`

	//VersionHoldMatrix 每个版本的hold节点数
	VersionHoldMatrix        map[string]int32   `json:"versionHoldMatrix,omitempty"`
	VersionHoldMatrixPercent map[string]float64 `json:"versionHoldMatrixPercent,omitempty"`
	//VersionDependencyReady 每个版本多少个节点依赖ok了，等比例挂流量
	VersionDependencyMatrix        map[string]int32   `json:"versionDependencyReady,omitempty"`
	VersionDependencyMatrixPercent map[string]float64 `json:"versionDependencyReadyPercent,omitempty"`
	// +optional 在同版本的情况,当subrsLatestVersionRatio，指定了更小的比例，是否可以回滚
	SubrsCanRollback bool `json:"subrsCanRollback,omitempty"`
	SubrsPaused      bool `json:"subrsPaused,omitempty"`
}

// VersionStatus 版本的状态
type VersionStatus struct {
	Version string `json:"version"`
	// Total number of non-terminated Replica targeted by this rollingset (their labels match the selector).
	// +optional
	Replicas int32 `json:"replicas"`

	// Total number of complete Replica,  latest version and available.
	// +optional
	ReadyReplicas int32 `json:"readyReplicas"`

	DataReadyReplicas int32 `json:"dataReadyReplicas"`

	// ref rollingset.spec.signature
	Signature string `json:"signature"`

	ResourceVersionStatus map[string]*ResourceVersionStatus `json:"resourceVersionStatus,omitempty"`
}

// ResourceVersionStatus 资源版本的状态
type ResourceVersionStatus struct {
	// CPU core数
	CPU int32 `json:"cpu"`
	// ResourceVersion 资源版本
	ResourceVersion string `json:"resourceVersion"`
	// Total number of non-terminated Replica targeted by this rollingset (their labels match the selector).
	// +optional
	Replicas int32 `json:"replicas"`

	// Total number of complete Replica,  latest version and available.
	// +optional
	AvailableReplicas int32 `json:"availableReplicas"`
}

func (in *SchedulePlan) getLatestVersionRatio() int32 {
	if nil == in.LatestVersionRatio {
		return 0
	}
	return *in.LatestVersionRatio
}

func (in *SchedulePlan) getPaddLatestVersionRatio() int32 {
	if nil == in.PaddedLatestVersionRatio {
		return 0
	}
	return *in.PaddedLatestVersionRatio
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SchedulePlan) DeepCopyInto(out *SchedulePlan) {
	*out = *in
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(int32)
		**out = **in
	}
	in.Strategy.DeepCopyInto(&out.Strategy)
	if in.LatestVersionRatio != nil {
		in, out := &in.LatestVersionRatio, &out.LatestVersionRatio
		*out = new(int32)
		**out = **in
	}
	if in.PaddedLatestVersionRatio != nil {
		in, out := &in.PaddedLatestVersionRatio, &out.PaddedLatestVersionRatio
		*out = new(int32)
		**out = **in
	}
	if in.VersionHoldMatrix != nil {
		in, out := &in.VersionHoldMatrix, &out.VersionHoldMatrix
		*out = make(map[string]int32, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.VersionHoldMatrixPercent != nil {
		in, out := &in.VersionHoldMatrixPercent, &out.VersionHoldMatrixPercent
		*out = make(map[string]float64, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SchedulePlan.
func (in *SchedulePlan) DeepCopy() *SchedulePlan {
	if in == nil {
		return nil
	}
	out := new(SchedulePlan)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto DeepCopyInto
func (in *VersionStatus) DeepCopyInto(out *VersionStatus) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VersionStatus.
func (in *VersionStatus) DeepCopy() *VersionStatus {
	if in == nil {
		return nil
	}
	out := new(VersionStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto DeepCopyInto
func (in *ResourceVersionStatus) DeepCopyInto(out *ResourceVersionStatus) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VersionStatus.
func (in *ResourceVersionStatus) DeepCopy() *ResourceVersionStatus {
	if in == nil {
		return nil
	}
	out := new(ResourceVersionStatus)
	in.DeepCopyInto(out)
	return out
}
