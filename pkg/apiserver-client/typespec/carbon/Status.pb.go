// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: carbon/Status.proto

package carbon

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/golang/protobuf/proto"
	hippo "github.com/alibaba/kube-sharding/pkg/apiserver-client/typespec/hippo"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SlotType int32

const (
	SlotType_ST_PKG_FAILED      SlotType = 0
	SlotType_ST_UNKNOWN         SlotType = 1
	SlotType_ST_DEAD            SlotType = 2
	SlotType_ST_PROC_FAILED     SlotType = 3
	SlotType_ST_PROC_RESTARTING SlotType = 4
	SlotType_ST_PROC_RUNNING    SlotType = 5
	SlotType_ST_PROC_TERMINATED SlotType = 6
)

var SlotType_name = map[int32]string{
	0: "ST_PKG_FAILED",
	1: "ST_UNKNOWN",
	2: "ST_DEAD",
	3: "ST_PROC_FAILED",
	4: "ST_PROC_RESTARTING",
	5: "ST_PROC_RUNNING",
	6: "ST_PROC_TERMINATED",
}

var SlotType_value = map[string]int32{
	"ST_PKG_FAILED":      0,
	"ST_UNKNOWN":         1,
	"ST_DEAD":            2,
	"ST_PROC_FAILED":     3,
	"ST_PROC_RESTARTING": 4,
	"ST_PROC_RUNNING":    5,
	"ST_PROC_TERMINATED": 6,
}

func (x SlotType) Enum() *SlotType {
	p := new(SlotType)
	*p = x
	return p
}

func (x SlotType) String() string {
	return proto.EnumName(SlotType_name, int32(x))
}

func (x *SlotType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SlotType_value, data, "SlotType")
	if err != nil {
		return err
	}
	*x = SlotType(value)
	return nil
}

func (SlotType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{0}
}

type HealthType int32

const (
	HealthType_HT_UNKNOWN HealthType = 0
	HealthType_HT_LOST    HealthType = 1
	HealthType_HT_ALIVE   HealthType = 2
	HealthType_HT_DEAD    HealthType = 3
)

var HealthType_name = map[int32]string{
	0: "HT_UNKNOWN",
	1: "HT_LOST",
	2: "HT_ALIVE",
	3: "HT_DEAD",
}

var HealthType_value = map[string]int32{
	"HT_UNKNOWN": 0,
	"HT_LOST":    1,
	"HT_ALIVE":   2,
	"HT_DEAD":    3,
}

func (x HealthType) Enum() *HealthType {
	p := new(HealthType)
	*p = x
	return p
}

func (x HealthType) String() string {
	return proto.EnumName(HealthType_name, int32(x))
}

func (x *HealthType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HealthType_value, data, "HealthType")
	if err != nil {
		return err
	}
	*x = HealthType(value)
	return nil
}

func (HealthType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{1}
}

type WorkerType int32

const (
	WorkerType_WT_UNKNOWN   WorkerType = 0
	WorkerType_WT_NOT_READY WorkerType = 1
	WorkerType_WT_READY     WorkerType = 2
)

var WorkerType_name = map[int32]string{
	0: "WT_UNKNOWN",
	1: "WT_NOT_READY",
	2: "WT_READY",
}

var WorkerType_value = map[string]int32{
	"WT_UNKNOWN":   0,
	"WT_NOT_READY": 1,
	"WT_READY":     2,
}

func (x WorkerType) Enum() *WorkerType {
	p := new(WorkerType)
	*p = x
	return p
}

func (x WorkerType) String() string {
	return proto.EnumName(WorkerType_name, int32(x))
}

func (x *WorkerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WorkerType_value, data, "WorkerType")
	if err != nil {
		return err
	}
	*x = WorkerType(value)
	return nil
}

func (WorkerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{2}
}

type ServiceType int32

const (
	ServiceType_SVT_UNKNOWN        ServiceType = 0
	ServiceType_SVT_UNAVAILABLE    ServiceType = 1
	ServiceType_SVT_PART_AVAILABLE ServiceType = 2
	ServiceType_SVT_AVAILABLE      ServiceType = 3
)

var ServiceType_name = map[int32]string{
	0: "SVT_UNKNOWN",
	1: "SVT_UNAVAILABLE",
	2: "SVT_PART_AVAILABLE",
	3: "SVT_AVAILABLE",
}

var ServiceType_value = map[string]int32{
	"SVT_UNKNOWN":        0,
	"SVT_UNAVAILABLE":    1,
	"SVT_PART_AVAILABLE": 2,
	"SVT_AVAILABLE":      3,
}

func (x ServiceType) Enum() *ServiceType {
	p := new(ServiceType)
	*p = x
	return p
}

func (x ServiceType) String() string {
	return proto.EnumName(ServiceType_name, int32(x))
}

func (x *ServiceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ServiceType_value, data, "ServiceType")
	if err != nil {
		return err
	}
	*x = ServiceType(value)
	return nil
}

func (ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{3}
}

type SlotAllocStatus int32

const (
	SlotAllocStatus_SAS_UNASSIGNED SlotAllocStatus = 0
	SlotAllocStatus_SAS_ASSIGNED   SlotAllocStatus = 1
	SlotAllocStatus_SAS_LOST       SlotAllocStatus = 2
	SlotAllocStatus_SAS_OFFLINING  SlotAllocStatus = 3
	SlotAllocStatus_SAS_RELEASING  SlotAllocStatus = 4
	SlotAllocStatus_SAS_RELEASED   SlotAllocStatus = 5
)

var SlotAllocStatus_name = map[int32]string{
	0: "SAS_UNASSIGNED",
	1: "SAS_ASSIGNED",
	2: "SAS_LOST",
	3: "SAS_OFFLINING",
	4: "SAS_RELEASING",
	5: "SAS_RELEASED",
}

var SlotAllocStatus_value = map[string]int32{
	"SAS_UNASSIGNED": 0,
	"SAS_ASSIGNED":   1,
	"SAS_LOST":       2,
	"SAS_OFFLINING":  3,
	"SAS_RELEASING":  4,
	"SAS_RELEASED":   5,
}

func (x SlotAllocStatus) Enum() *SlotAllocStatus {
	p := new(SlotAllocStatus)
	*p = x
	return p
}

func (x SlotAllocStatus) String() string {
	return proto.EnumName(SlotAllocStatus_name, int32(x))
}

func (x *SlotAllocStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SlotAllocStatus_value, data, "SlotAllocStatus")
	if err != nil {
		return err
	}
	*x = SlotAllocStatus(value)
	return nil
}

func (SlotAllocStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{4}
}

type HealthInfo struct {
	HealthStatus         *HealthType       `protobuf:"varint,1,opt,name=healthStatus,enum=carbon.HealthType,def=0" json:"healthStatus,omitempty"`
	WorkerStatus         *WorkerType       `protobuf:"varint,2,opt,name=workerStatus,enum=carbon.WorkerType,def=0" json:"workerStatus,omitempty"`
	Metas                map[string]string `protobuf:"bytes,3,rep,name=metas" json:"metas,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Version              *string           `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HealthInfo) Reset()         { *m = HealthInfo{} }
func (m *HealthInfo) String() string { return proto.CompactTextString(m) }
func (*HealthInfo) ProtoMessage()    {}
func (*HealthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{0}
}
func (m *HealthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthInfo.Merge(m, src)
}
func (m *HealthInfo) XXX_Size() int {
	return m.Size()
}
func (m *HealthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HealthInfo proto.InternalMessageInfo

const Default_HealthInfo_HealthStatus HealthType = HealthType_HT_UNKNOWN
const Default_HealthInfo_WorkerStatus WorkerType = WorkerType_WT_UNKNOWN

func (m *HealthInfo) GetHealthStatus() HealthType {
	if m != nil && m.HealthStatus != nil {
		return *m.HealthStatus
	}
	return Default_HealthInfo_HealthStatus
}

func (m *HealthInfo) GetWorkerStatus() WorkerType {
	if m != nil && m.WorkerStatus != nil {
		return *m.WorkerStatus
	}
	return Default_HealthInfo_WorkerStatus
}

func (m *HealthInfo) GetMetas() map[string]string {
	if m != nil {
		return m.Metas
	}
	return nil
}

func (m *HealthInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

type ServiceStatus struct {
	Status               *ServiceType      `protobuf:"varint,1,opt,name=status,enum=carbon.ServiceType,def=0" json:"status,omitempty"`
	Metas                map[string]string `protobuf:"bytes,2,rep,name=metas" json:"metas,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Score                *int64            `protobuf:"varint,3,opt,name=score,def=0" json:"score,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServiceStatus) Reset()         { *m = ServiceStatus{} }
func (m *ServiceStatus) String() string { return proto.CompactTextString(m) }
func (*ServiceStatus) ProtoMessage()    {}
func (*ServiceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{1}
}
func (m *ServiceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceStatus.Merge(m, src)
}
func (m *ServiceStatus) XXX_Size() int {
	return m.Size()
}
func (m *ServiceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceStatus proto.InternalMessageInfo

const Default_ServiceStatus_Status ServiceType = ServiceType_SVT_UNKNOWN
const Default_ServiceStatus_Score int64 = 0

func (m *ServiceStatus) GetStatus() ServiceType {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_ServiceStatus_Status
}

func (m *ServiceStatus) GetMetas() map[string]string {
	if m != nil {
		return m.Metas
	}
	return nil
}

func (m *ServiceStatus) GetScore() int64 {
	if m != nil && m.Score != nil {
		return *m.Score
	}
	return Default_ServiceStatus_Score
}

type SlotStatus struct {
	Status               *SlotType     `protobuf:"varint,1,opt,name=status,enum=carbon.SlotType,def=1" json:"status,omitempty"`
	SlotId               *hippo.SlotId `protobuf:"bytes,2,opt,name=slotId" json:"slotId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SlotStatus) Reset()         { *m = SlotStatus{} }
func (m *SlotStatus) String() string { return proto.CompactTextString(m) }
func (*SlotStatus) ProtoMessage()    {}
func (*SlotStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{2}
}
func (m *SlotStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlotStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlotStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlotStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlotStatus.Merge(m, src)
}
func (m *SlotStatus) XXX_Size() int {
	return m.Size()
}
func (m *SlotStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SlotStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SlotStatus proto.InternalMessageInfo

const Default_SlotStatus_Status SlotType = SlotType_ST_UNKNOWN

func (m *SlotStatus) GetStatus() SlotType {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_SlotStatus_Status
}

func (m *SlotStatus) GetSlotId() *hippo.SlotId {
	if m != nil {
		return m.SlotId
	}
	return nil
}

type SlotInfo struct {
	Role                             *string                `protobuf:"bytes,1,opt,name=role" json:"role,omitempty"`
	SlotId                           *hippo.SlotId          `protobuf:"bytes,2,opt,name=slotId" json:"slotId,omitempty"`
	Reclaiming                       *bool                  `protobuf:"varint,3,opt,name=reclaiming" json:"reclaiming,omitempty"`
	SlotResource                     *SlotResource          `protobuf:"bytes,4,opt,name=slotResource" json:"slotResource,omitempty"`
	ProcessStatus                    []*hippo.ProcessStatus `protobuf:"bytes,5,rep,name=processStatus" json:"processStatus,omitempty"`
	SlaveStatus                      *hippo.SlaveStatus     `protobuf:"bytes,6,opt,name=slaveStatus" json:"slaveStatus,omitempty"`
	LaunchSignature                  *int64                 `protobuf:"varint,8,opt,name=launchSignature" json:"launchSignature,omitempty"`
	PackageChecksum                  *string                `protobuf:"bytes,9,opt,name=packageChecksum" json:"packageChecksum,omitempty"`
	PackageStatus                    *hippo.PackageStatus   `protobuf:"bytes,10,opt,name=packageStatus" json:"packageStatus,omitempty"`
	NoLongerMatchQueue               *bool                  `protobuf:"varint,13,opt,name=noLongerMatchQueue,def=0" json:"noLongerMatchQueue,omitempty"`
	NoLongerMatchResourceRequirement *bool                  `protobuf:"varint,14,opt,name=noLongerMatchResourceRequirement,def=0" json:"noLongerMatchResourceRequirement,omitempty"`
	PreDeployPackageChecksum         *string                `protobuf:"bytes,18,opt,name=preDeployPackageChecksum" json:"preDeployPackageChecksum,omitempty"`
	PreDeployPackageStatus           *hippo.PackageStatus   `protobuf:"bytes,19,opt,name=preDeployPackageStatus" json:"preDeployPackageStatus,omitempty"`
	RequirementId                    *string                `protobuf:"bytes,23,opt,name=requirementId" json:"requirementId,omitempty"`
	Priority                         *hippo.Priority        `protobuf:"bytes,24,opt,name=priority" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}               `json:"-"`
	XXX_unrecognized                 []byte                 `json:"-"`
	XXX_sizecache                    int32                  `json:"-"`
}

func (m *SlotInfo) Reset()         { *m = SlotInfo{} }
func (m *SlotInfo) String() string { return proto.CompactTextString(m) }
func (*SlotInfo) ProtoMessage()    {}
func (*SlotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{3}
}
func (m *SlotInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlotInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlotInfo.Merge(m, src)
}
func (m *SlotInfo) XXX_Size() int {
	return m.Size()
}
func (m *SlotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SlotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SlotInfo proto.InternalMessageInfo

const Default_SlotInfo_NoLongerMatchQueue bool = false
const Default_SlotInfo_NoLongerMatchResourceRequirement bool = false

func (m *SlotInfo) GetRole() string {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return ""
}

func (m *SlotInfo) GetSlotId() *hippo.SlotId {
	if m != nil {
		return m.SlotId
	}
	return nil
}

func (m *SlotInfo) GetReclaiming() bool {
	if m != nil && m.Reclaiming != nil {
		return *m.Reclaiming
	}
	return false
}

func (m *SlotInfo) GetSlotResource() *SlotResource {
	if m != nil {
		return m.SlotResource
	}
	return nil
}

func (m *SlotInfo) GetProcessStatus() []*hippo.ProcessStatus {
	if m != nil {
		return m.ProcessStatus
	}
	return nil
}

func (m *SlotInfo) GetSlaveStatus() *hippo.SlaveStatus {
	if m != nil {
		return m.SlaveStatus
	}
	return nil
}

func (m *SlotInfo) GetLaunchSignature() int64 {
	if m != nil && m.LaunchSignature != nil {
		return *m.LaunchSignature
	}
	return 0
}

func (m *SlotInfo) GetPackageChecksum() string {
	if m != nil && m.PackageChecksum != nil {
		return *m.PackageChecksum
	}
	return ""
}

func (m *SlotInfo) GetPackageStatus() *hippo.PackageStatus {
	if m != nil {
		return m.PackageStatus
	}
	return nil
}

func (m *SlotInfo) GetNoLongerMatchQueue() bool {
	if m != nil && m.NoLongerMatchQueue != nil {
		return *m.NoLongerMatchQueue
	}
	return Default_SlotInfo_NoLongerMatchQueue
}

func (m *SlotInfo) GetNoLongerMatchResourceRequirement() bool {
	if m != nil && m.NoLongerMatchResourceRequirement != nil {
		return *m.NoLongerMatchResourceRequirement
	}
	return Default_SlotInfo_NoLongerMatchResourceRequirement
}

func (m *SlotInfo) GetPreDeployPackageChecksum() string {
	if m != nil && m.PreDeployPackageChecksum != nil {
		return *m.PreDeployPackageChecksum
	}
	return ""
}

func (m *SlotInfo) GetPreDeployPackageStatus() *hippo.PackageStatus {
	if m != nil {
		return m.PreDeployPackageStatus
	}
	return nil
}

func (m *SlotInfo) GetRequirementId() string {
	if m != nil && m.RequirementId != nil {
		return *m.RequirementId
	}
	return ""
}

func (m *SlotInfo) GetPriority() *hippo.Priority {
	if m != nil {
		return m.Priority
	}
	return nil
}

type WorkerNodeStatus struct {
	ReplicaNodeId        *string           `protobuf:"bytes,1,opt,name=replicaNodeId" json:"replicaNodeId,omitempty"`
	WorkerNodeId         *string           `protobuf:"bytes,2,opt,name=workerNodeId" json:"workerNodeId,omitempty"`
	CurVersion           *string           `protobuf:"bytes,3,opt,name=curVersion" json:"curVersion,omitempty"`
	NextVersion          *string           `protobuf:"bytes,4,opt,name=nextVersion" json:"nextVersion,omitempty"`
	FinalVersion         *string           `protobuf:"bytes,5,opt,name=finalVersion" json:"finalVersion,omitempty"`
	Offline              *bool             `protobuf:"varint,6,opt,name=offline,def=0" json:"offline,omitempty"`
	Releasing            *bool             `protobuf:"varint,7,opt,name=releasing,def=0" json:"releasing,omitempty"`
	Reclaiming           *bool             `protobuf:"varint,8,opt,name=reclaiming,def=0" json:"reclaiming,omitempty"`
	ReadyForCurVersion   *bool             `protobuf:"varint,9,opt,name=readyForCurVersion,def=0" json:"readyForCurVersion,omitempty"`
	IsBackup             *bool             `protobuf:"varint,10,opt,name=isBackup,def=0" json:"isBackup,omitempty"`
	LastNotMatchTime     *int64            `protobuf:"varint,11,opt,name=lastNotMatchTime,def=0" json:"lastNotMatchTime,omitempty"`
	LastNotReadyTime     *int64            `protobuf:"varint,12,opt,name=lastNotReadyTime,def=0" json:"lastNotReadyTime,omitempty"`
	SlotAllocStatus      *SlotAllocStatus  `protobuf:"varint,13,opt,name=slotAllocStatus,enum=carbon.SlotAllocStatus,def=0" json:"slotAllocStatus,omitempty"`
	SlotInfo             *SlotInfo         `protobuf:"bytes,14,opt,name=slotInfo" json:"slotInfo,omitempty"`
	HealthInfo           *HealthInfo       `protobuf:"bytes,15,opt,name=healthInfo" json:"healthInfo,omitempty"`
	ServiceInfo          *ServiceStatus    `protobuf:"bytes,16,opt,name=serviceInfo" json:"serviceInfo,omitempty"`
	SlotStatus           *SlotStatus       `protobuf:"bytes,17,opt,name=slotStatus" json:"slotStatus,omitempty"`
	Ip                   *string           `protobuf:"bytes,18,opt,name=ip" json:"ip,omitempty"`
	UserDefVersion       *string           `protobuf:"bytes,19,opt,name=userDefVersion" json:"userDefVersion,omitempty"`
	TargetSignature      *string           `protobuf:"bytes,20,opt,name=targetSignature" json:"targetSignature,omitempty"`
	TargetCustomInfo     *string           `protobuf:"bytes,21,opt,name=targetCustomInfo" json:"targetCustomInfo,omitempty"`
	WorkerMode           *string           `protobuf:"bytes,22,opt,name=workerMode" json:"workerMode,omitempty"`
	Labels               map[string]string `protobuf:"bytes,23,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WorkerNodeStatus) Reset()         { *m = WorkerNodeStatus{} }
func (m *WorkerNodeStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeStatus) ProtoMessage()    {}
func (*WorkerNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{4}
}
func (m *WorkerNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeStatus.Merge(m, src)
}
func (m *WorkerNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeStatus proto.InternalMessageInfo

const Default_WorkerNodeStatus_Offline bool = false
const Default_WorkerNodeStatus_Releasing bool = false
const Default_WorkerNodeStatus_Reclaiming bool = false
const Default_WorkerNodeStatus_ReadyForCurVersion bool = false
const Default_WorkerNodeStatus_IsBackup bool = false
const Default_WorkerNodeStatus_LastNotMatchTime int64 = 0
const Default_WorkerNodeStatus_LastNotReadyTime int64 = 0
const Default_WorkerNodeStatus_SlotAllocStatus SlotAllocStatus = SlotAllocStatus_SAS_UNASSIGNED

func (m *WorkerNodeStatus) GetReplicaNodeId() string {
	if m != nil && m.ReplicaNodeId != nil {
		return *m.ReplicaNodeId
	}
	return ""
}

func (m *WorkerNodeStatus) GetWorkerNodeId() string {
	if m != nil && m.WorkerNodeId != nil {
		return *m.WorkerNodeId
	}
	return ""
}

func (m *WorkerNodeStatus) GetCurVersion() string {
	if m != nil && m.CurVersion != nil {
		return *m.CurVersion
	}
	return ""
}

func (m *WorkerNodeStatus) GetNextVersion() string {
	if m != nil && m.NextVersion != nil {
		return *m.NextVersion
	}
	return ""
}

func (m *WorkerNodeStatus) GetFinalVersion() string {
	if m != nil && m.FinalVersion != nil {
		return *m.FinalVersion
	}
	return ""
}

func (m *WorkerNodeStatus) GetOffline() bool {
	if m != nil && m.Offline != nil {
		return *m.Offline
	}
	return Default_WorkerNodeStatus_Offline
}

func (m *WorkerNodeStatus) GetReleasing() bool {
	if m != nil && m.Releasing != nil {
		return *m.Releasing
	}
	return Default_WorkerNodeStatus_Releasing
}

func (m *WorkerNodeStatus) GetReclaiming() bool {
	if m != nil && m.Reclaiming != nil {
		return *m.Reclaiming
	}
	return Default_WorkerNodeStatus_Reclaiming
}

func (m *WorkerNodeStatus) GetReadyForCurVersion() bool {
	if m != nil && m.ReadyForCurVersion != nil {
		return *m.ReadyForCurVersion
	}
	return Default_WorkerNodeStatus_ReadyForCurVersion
}

func (m *WorkerNodeStatus) GetIsBackup() bool {
	if m != nil && m.IsBackup != nil {
		return *m.IsBackup
	}
	return Default_WorkerNodeStatus_IsBackup
}

func (m *WorkerNodeStatus) GetLastNotMatchTime() int64 {
	if m != nil && m.LastNotMatchTime != nil {
		return *m.LastNotMatchTime
	}
	return Default_WorkerNodeStatus_LastNotMatchTime
}

func (m *WorkerNodeStatus) GetLastNotReadyTime() int64 {
	if m != nil && m.LastNotReadyTime != nil {
		return *m.LastNotReadyTime
	}
	return Default_WorkerNodeStatus_LastNotReadyTime
}

func (m *WorkerNodeStatus) GetSlotAllocStatus() SlotAllocStatus {
	if m != nil && m.SlotAllocStatus != nil {
		return *m.SlotAllocStatus
	}
	return Default_WorkerNodeStatus_SlotAllocStatus
}

func (m *WorkerNodeStatus) GetSlotInfo() *SlotInfo {
	if m != nil {
		return m.SlotInfo
	}
	return nil
}

func (m *WorkerNodeStatus) GetHealthInfo() *HealthInfo {
	if m != nil {
		return m.HealthInfo
	}
	return nil
}

func (m *WorkerNodeStatus) GetServiceInfo() *ServiceStatus {
	if m != nil {
		return m.ServiceInfo
	}
	return nil
}

func (m *WorkerNodeStatus) GetSlotStatus() *SlotStatus {
	if m != nil {
		return m.SlotStatus
	}
	return nil
}

func (m *WorkerNodeStatus) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *WorkerNodeStatus) GetUserDefVersion() string {
	if m != nil && m.UserDefVersion != nil {
		return *m.UserDefVersion
	}
	return ""
}

func (m *WorkerNodeStatus) GetTargetSignature() string {
	if m != nil && m.TargetSignature != nil {
		return *m.TargetSignature
	}
	return ""
}

func (m *WorkerNodeStatus) GetTargetCustomInfo() string {
	if m != nil && m.TargetCustomInfo != nil {
		return *m.TargetCustomInfo
	}
	return ""
}

func (m *WorkerNodeStatus) GetWorkerMode() string {
	if m != nil && m.WorkerMode != nil {
		return *m.WorkerMode
	}
	return ""
}

func (m *WorkerNodeStatus) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type ReplicaNodeStatus struct {
	ReplicaNodeId          *string           `protobuf:"bytes,1,opt,name=replicaNodeId" json:"replicaNodeId,omitempty"`
	CurWorkerNodeStatus    *WorkerNodeStatus `protobuf:"bytes,2,opt,name=curWorkerNodeStatus" json:"curWorkerNodeStatus,omitempty"`
	BackupWorkerNodeStatus *WorkerNodeStatus `protobuf:"bytes,3,opt,name=backupWorkerNodeStatus" json:"backupWorkerNodeStatus,omitempty"`
	TimeStamp              *int64            `protobuf:"varint,4,opt,name=timeStamp,def=0" json:"timeStamp,omitempty"`
	UserDefVersion         *string           `protobuf:"bytes,5,opt,name=userDefVersion" json:"userDefVersion,omitempty"`
	ReadyForCurVersion     *bool             `protobuf:"varint,6,opt,name=readyForCurVersion,def=0" json:"readyForCurVersion,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}          `json:"-"`
	XXX_unrecognized       []byte            `json:"-"`
	XXX_sizecache          int32             `json:"-"`
}

func (m *ReplicaNodeStatus) Reset()         { *m = ReplicaNodeStatus{} }
func (m *ReplicaNodeStatus) String() string { return proto.CompactTextString(m) }
func (*ReplicaNodeStatus) ProtoMessage()    {}
func (*ReplicaNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{5}
}
func (m *ReplicaNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaNodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaNodeStatus.Merge(m, src)
}
func (m *ReplicaNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaNodeStatus proto.InternalMessageInfo

const Default_ReplicaNodeStatus_TimeStamp int64 = 0
const Default_ReplicaNodeStatus_ReadyForCurVersion bool = false

func (m *ReplicaNodeStatus) GetReplicaNodeId() string {
	if m != nil && m.ReplicaNodeId != nil {
		return *m.ReplicaNodeId
	}
	return ""
}

func (m *ReplicaNodeStatus) GetCurWorkerNodeStatus() *WorkerNodeStatus {
	if m != nil {
		return m.CurWorkerNodeStatus
	}
	return nil
}

func (m *ReplicaNodeStatus) GetBackupWorkerNodeStatus() *WorkerNodeStatus {
	if m != nil {
		return m.BackupWorkerNodeStatus
	}
	return nil
}

func (m *ReplicaNodeStatus) GetTimeStamp() int64 {
	if m != nil && m.TimeStamp != nil {
		return *m.TimeStamp
	}
	return Default_ReplicaNodeStatus_TimeStamp
}

func (m *ReplicaNodeStatus) GetUserDefVersion() string {
	if m != nil && m.UserDefVersion != nil {
		return *m.UserDefVersion
	}
	return ""
}

func (m *ReplicaNodeStatus) GetReadyForCurVersion() bool {
	if m != nil && m.ReadyForCurVersion != nil {
		return *m.ReadyForCurVersion
	}
	return Default_ReplicaNodeStatus_ReadyForCurVersion
}

type GlobalPlan struct {
	Count                *int32   `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	LatestVersionRatio   *int32   `protobuf:"varint,2,opt,name=latestVersionRatio,def=100" json:"latestVersionRatio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobalPlan) Reset()         { *m = GlobalPlan{} }
func (m *GlobalPlan) String() string { return proto.CompactTextString(m) }
func (*GlobalPlan) ProtoMessage()    {}
func (*GlobalPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{6}
}
func (m *GlobalPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalPlan.Merge(m, src)
}
func (m *GlobalPlan) XXX_Size() int {
	return m.Size()
}
func (m *GlobalPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalPlan.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalPlan proto.InternalMessageInfo

const Default_GlobalPlan_LatestVersionRatio int32 = 100

func (m *GlobalPlan) GetCount() int32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *GlobalPlan) GetLatestVersionRatio() int32 {
	if m != nil && m.LatestVersionRatio != nil {
		return *m.LatestVersionRatio
	}
	return Default_GlobalPlan_LatestVersionRatio
}

type RoleStatusValue struct {
	RoleId                    *string                   `protobuf:"bytes,1,opt,name=roleId" json:"roleId,omitempty"`
	GlobalPlan                *GlobalPlan               `protobuf:"bytes,2,opt,name=globalPlan" json:"globalPlan,omitempty"`
	VersionedPlans            map[string]*VersionedPlan `protobuf:"bytes,3,rep,name=versionedPlans" json:"versionedPlans,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	LatestVersion             *string                   `protobuf:"bytes,4,opt,name=latestVersion" json:"latestVersion,omitempty"`
	Nodes                     []*ReplicaNodeStatus      `protobuf:"bytes,5,rep,name=nodes" json:"nodes,omitempty"`
	UserDefVersion            *string                   `protobuf:"bytes,6,opt,name=userDefVersion" json:"userDefVersion,omitempty"`
	ReadyForCurVersion        *bool                     `protobuf:"varint,7,opt,name=readyForCurVersion,def=0" json:"readyForCurVersion,omitempty"`
	MinHealthCapacity         *int32                    `protobuf:"varint,8,opt,name=minHealthCapacity" json:"minHealthCapacity,omitempty"`
	AdjustedCount             *int32                    `protobuf:"varint,9,opt,name=adjustedCount" json:"adjustedCount,omitempty"`
	AdjustedMinHealthCapacity *int32                    `protobuf:"varint,10,opt,name=adjustedMinHealthCapacity" json:"adjustedMinHealthCapacity,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                  `json:"-"`
	XXX_unrecognized          []byte                    `json:"-"`
	XXX_sizecache             int32                     `json:"-"`
}

func (m *RoleStatusValue) Reset()         { *m = RoleStatusValue{} }
func (m *RoleStatusValue) String() string { return proto.CompactTextString(m) }
func (*RoleStatusValue) ProtoMessage()    {}
func (*RoleStatusValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{7}
}
func (m *RoleStatusValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleStatusValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleStatusValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleStatusValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleStatusValue.Merge(m, src)
}
func (m *RoleStatusValue) XXX_Size() int {
	return m.Size()
}
func (m *RoleStatusValue) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleStatusValue.DiscardUnknown(m)
}

var xxx_messageInfo_RoleStatusValue proto.InternalMessageInfo

const Default_RoleStatusValue_ReadyForCurVersion bool = false

func (m *RoleStatusValue) GetRoleId() string {
	if m != nil && m.RoleId != nil {
		return *m.RoleId
	}
	return ""
}

func (m *RoleStatusValue) GetGlobalPlan() *GlobalPlan {
	if m != nil {
		return m.GlobalPlan
	}
	return nil
}

func (m *RoleStatusValue) GetVersionedPlans() map[string]*VersionedPlan {
	if m != nil {
		return m.VersionedPlans
	}
	return nil
}

func (m *RoleStatusValue) GetLatestVersion() string {
	if m != nil && m.LatestVersion != nil {
		return *m.LatestVersion
	}
	return ""
}

func (m *RoleStatusValue) GetNodes() []*ReplicaNodeStatus {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *RoleStatusValue) GetUserDefVersion() string {
	if m != nil && m.UserDefVersion != nil {
		return *m.UserDefVersion
	}
	return ""
}

func (m *RoleStatusValue) GetReadyForCurVersion() bool {
	if m != nil && m.ReadyForCurVersion != nil {
		return *m.ReadyForCurVersion
	}
	return Default_RoleStatusValue_ReadyForCurVersion
}

func (m *RoleStatusValue) GetMinHealthCapacity() int32 {
	if m != nil && m.MinHealthCapacity != nil {
		return *m.MinHealthCapacity
	}
	return 0
}

func (m *RoleStatusValue) GetAdjustedCount() int32 {
	if m != nil && m.AdjustedCount != nil {
		return *m.AdjustedCount
	}
	return 0
}

func (m *RoleStatusValue) GetAdjustedMinHealthCapacity() int32 {
	if m != nil && m.AdjustedMinHealthCapacity != nil {
		return *m.AdjustedMinHealthCapacity
	}
	return 0
}

type GroupStatus struct {
	GroupId              *string                     `protobuf:"bytes,1,opt,name=groupId" json:"groupId,omitempty"`
	Roles                map[string]*RoleStatusValue `protobuf:"bytes,3,rep,name=roles" json:"roles,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *GroupStatus) Reset()         { *m = GroupStatus{} }
func (m *GroupStatus) String() string { return proto.CompactTextString(m) }
func (*GroupStatus) ProtoMessage()    {}
func (*GroupStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{8}
}
func (m *GroupStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupStatus.Merge(m, src)
}
func (m *GroupStatus) XXX_Size() int {
	return m.Size()
}
func (m *GroupStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupStatus.DiscardUnknown(m)
}

var xxx_messageInfo_GroupStatus proto.InternalMessageInfo

func (m *GroupStatus) GetGroupId() string {
	if m != nil && m.GroupId != nil {
		return *m.GroupId
	}
	return ""
}

func (m *GroupStatus) GetRoles() map[string]*RoleStatusValue {
	if m != nil {
		return m.Roles
	}
	return nil
}

type Response struct {
	Code                 *int32         `protobuf:"varint,1,opt,name=code,def=0" json:"code,omitempty"`
	SubCode              *int32         `protobuf:"varint,2,opt,name=subCode,def=0" json:"subCode,omitempty"`
	Msg                  *string        `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
	Data                 []*GroupStatus `protobuf:"bytes,4,rep,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{9}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

const Default_Response_Code int32 = 0
const Default_Response_SubCode int32 = 0

func (m *Response) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return Default_Response_Code
}

func (m *Response) GetSubCode() int32 {
	if m != nil && m.SubCode != nil {
		return *m.SubCode
	}
	return Default_Response_SubCode
}

func (m *Response) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

func (m *Response) GetData() []*GroupStatus {
	if m != nil {
		return m.Data
	}
	return nil
}

type CarbonPriority struct {
	MajorPriority        *int32   `protobuf:"varint,1,opt,name=major_priority,json=majorPriority,def=32" json:"major_priority,omitempty"`
	MinorPriority        *int32   `protobuf:"varint,2,opt,name=minor_priority,json=minorPriority" json:"minor_priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CarbonPriority) Reset()         { *m = CarbonPriority{} }
func (m *CarbonPriority) String() string { return proto.CompactTextString(m) }
func (*CarbonPriority) ProtoMessage()    {}
func (*CarbonPriority) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{10}
}
func (m *CarbonPriority) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CarbonPriority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CarbonPriority.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CarbonPriority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CarbonPriority.Merge(m, src)
}
func (m *CarbonPriority) XXX_Size() int {
	return m.Size()
}
func (m *CarbonPriority) XXX_DiscardUnknown() {
	xxx_messageInfo_CarbonPriority.DiscardUnknown(m)
}

var xxx_messageInfo_CarbonPriority proto.InternalMessageInfo

const Default_CarbonPriority_MajorPriority int32 = 32

func (m *CarbonPriority) GetMajorPriority() int32 {
	if m != nil && m.MajorPriority != nil {
		return *m.MajorPriority
	}
	return Default_CarbonPriority_MajorPriority
}

func (m *CarbonPriority) GetMinorPriority() int32 {
	if m != nil && m.MinorPriority != nil {
		return *m.MinorPriority
	}
	return 0
}

type SlotResource struct {
	SlotResources        []*hippo.Resource `protobuf:"bytes,1,rep,name=slotResources" json:"slotResources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SlotResource) Reset()         { *m = SlotResource{} }
func (m *SlotResource) String() string { return proto.CompactTextString(m) }
func (*SlotResource) ProtoMessage()    {}
func (*SlotResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{11}
}
func (m *SlotResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlotResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlotResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlotResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlotResource.Merge(m, src)
}
func (m *SlotResource) XXX_Size() int {
	return m.Size()
}
func (m *SlotResource) XXX_DiscardUnknown() {
	xxx_messageInfo_SlotResource.DiscardUnknown(m)
}

var xxx_messageInfo_SlotResource proto.InternalMessageInfo

func (m *SlotResource) GetSlotResources() []*hippo.Resource {
	if m != nil {
		return m.SlotResources
	}
	return nil
}

type ResourcePlan struct {
	Resources            []*SlotResource `protobuf:"bytes,1,rep,name=resources" json:"resources,omitempty"`
	Group                *string         `protobuf:"bytes,2,opt,name=group" json:"group,omitempty"`
	Priority             *CarbonPriority `protobuf:"bytes,3,opt,name=priority" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ResourcePlan) Reset()         { *m = ResourcePlan{} }
func (m *ResourcePlan) String() string { return proto.CompactTextString(m) }
func (*ResourcePlan) ProtoMessage()    {}
func (*ResourcePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{12}
}
func (m *ResourcePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcePlan.Merge(m, src)
}
func (m *ResourcePlan) XXX_Size() int {
	return m.Size()
}
func (m *ResourcePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcePlan.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcePlan proto.InternalMessageInfo

func (m *ResourcePlan) GetResources() []*SlotResource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ResourcePlan) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *ResourcePlan) GetPriority() *CarbonPriority {
	if m != nil {
		return m.Priority
	}
	return nil
}

type VersionedPlan struct {
	ResourcePlan         *ResourcePlan `protobuf:"bytes,1,opt,name=resourcePlan" json:"resourcePlan,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *VersionedPlan) Reset()         { *m = VersionedPlan{} }
func (m *VersionedPlan) String() string { return proto.CompactTextString(m) }
func (*VersionedPlan) ProtoMessage()    {}
func (*VersionedPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_5bb0045bb7487277, []int{13}
}
func (m *VersionedPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionedPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionedPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionedPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionedPlan.Merge(m, src)
}
func (m *VersionedPlan) XXX_Size() int {
	return m.Size()
}
func (m *VersionedPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionedPlan.DiscardUnknown(m)
}

var xxx_messageInfo_VersionedPlan proto.InternalMessageInfo

func (m *VersionedPlan) GetResourcePlan() *ResourcePlan {
	if m != nil {
		return m.ResourcePlan
	}
	return nil
}

func init() {
	proto.RegisterEnum("carbon.SlotType", SlotType_name, SlotType_value)
	proto.RegisterEnum("carbon.HealthType", HealthType_name, HealthType_value)
	proto.RegisterEnum("carbon.WorkerType", WorkerType_name, WorkerType_value)
	proto.RegisterEnum("carbon.ServiceType", ServiceType_name, ServiceType_value)
	proto.RegisterEnum("carbon.SlotAllocStatus", SlotAllocStatus_name, SlotAllocStatus_value)
	proto.RegisterType((*HealthInfo)(nil), "carbon.HealthInfo")
	proto.RegisterMapType((map[string]string)(nil), "carbon.HealthInfo.MetasEntry")
	proto.RegisterType((*ServiceStatus)(nil), "carbon.ServiceStatus")
	proto.RegisterMapType((map[string]string)(nil), "carbon.ServiceStatus.MetasEntry")
	proto.RegisterType((*SlotStatus)(nil), "carbon.SlotStatus")
	proto.RegisterType((*SlotInfo)(nil), "carbon.SlotInfo")
	proto.RegisterType((*WorkerNodeStatus)(nil), "carbon.WorkerNodeStatus")
	proto.RegisterMapType((map[string]string)(nil), "carbon.WorkerNodeStatus.LabelsEntry")
	proto.RegisterType((*ReplicaNodeStatus)(nil), "carbon.ReplicaNodeStatus")
	proto.RegisterType((*GlobalPlan)(nil), "carbon.GlobalPlan")
	proto.RegisterType((*RoleStatusValue)(nil), "carbon.RoleStatusValue")
	proto.RegisterMapType((map[string]*VersionedPlan)(nil), "carbon.RoleStatusValue.VersionedPlansEntry")
	proto.RegisterType((*GroupStatus)(nil), "carbon.GroupStatus")
	proto.RegisterMapType((map[string]*RoleStatusValue)(nil), "carbon.GroupStatus.RolesEntry")
	proto.RegisterType((*Response)(nil), "carbon.Response")
	proto.RegisterType((*CarbonPriority)(nil), "carbon.CarbonPriority")
	proto.RegisterType((*SlotResource)(nil), "carbon.SlotResource")
	proto.RegisterType((*ResourcePlan)(nil), "carbon.ResourcePlan")
	proto.RegisterType((*VersionedPlan)(nil), "carbon.VersionedPlan")
}

func init() { proto.RegisterFile("carbon/Status.proto", fileDescriptor_5bb0045bb7487277) }

var fileDescriptor_5bb0045bb7487277 = []byte{
	// 1797 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x4f, 0x73, 0x1b, 0x4b,
	0x11, 0xcf, 0x4a, 0x96, 0x2c, 0xb7, 0x2c, 0x79, 0x33, 0x4e, 0xec, 0x7d, 0xa6, 0xf0, 0x33, 0xe2,
	0x05, 0x8c, 0xf3, 0x9e, 0x13, 0x9c, 0x04, 0x82, 0x2b, 0x17, 0x45, 0x52, 0x1c, 0xf1, 0x64, 0xd9,
	0x19, 0x29, 0x32, 0x5c, 0x50, 0xad, 0x57, 0x63, 0x7b, 0x9f, 0x57, 0x3b, 0xcb, 0xfe, 0x09, 0xf8,
	0x40, 0x15, 0x47, 0x0e, 0x1c, 0xa8, 0xe2, 0xc2, 0x85, 0xef, 0xf0, 0x3e, 0x06, 0x47, 0x0e, 0xa9,
	0xe2, 0x4a, 0x85, 0x2f, 0x42, 0x4d, 0xcf, 0xfe, 0x99, 0x95, 0x64, 0x42, 0xea, 0xdd, 0x76, 0x7e,
	0xfd, 0x9b, 0x9e, 0xee, 0x9e, 0xee, 0x9e, 0x99, 0x85, 0x75, 0xcb, 0xf4, 0xcf, 0xb9, 0xfb, 0x68,
	0x10, 0x9a, 0x61, 0x14, 0xec, 0x7b, 0x3e, 0x0f, 0x39, 0x29, 0x4b, 0x70, 0x8b, 0x5c, 0xd9, 0x9e,
	0xc7, 0x1f, 0xb5, 0xf8, 0x74, 0xca, 0x5d, 0x29, 0x6b, 0xfc, 0xbd, 0x00, 0xf0, 0x9a, 0x99, 0x4e,
	0x78, 0xd5, 0x75, 0x2f, 0x38, 0x79, 0x09, 0xab, 0x57, 0x38, 0x92, 0x0a, 0x0c, 0x6d, 0x47, 0xdb,
	0xad, 0x1f, 0x90, 0x7d, 0xa9, 0x61, 0x5f, 0x32, 0x87, 0x37, 0x1e, 0x3b, 0x84, 0xd7, 0xc3, 0xf1,
	0xdb, 0xfe, 0xd7, 0xfd, 0x93, 0xb3, 0x3e, 0xcd, 0xcd, 0x11, 0x3a, 0x7e, 0xc7, 0xfd, 0x6b, 0xe6,
	0xc7, 0x3a, 0x0a, 0x79, 0x1d, 0x67, 0x28, 0x93, 0x3a, 0xce, 0x14, 0x1d, 0xea, 0x1c, 0xf2, 0x04,
	0x4a, 0x53, 0x16, 0x9a, 0x81, 0x51, 0xdc, 0x29, 0xee, 0x56, 0x0f, 0xbe, 0x9f, 0x37, 0x40, 0x98,
	0xba, 0x7f, 0x2c, 0xe4, 0x1d, 0x37, 0xf4, 0x6f, 0xa8, 0xe4, 0x12, 0x03, 0x96, 0xdf, 0x31, 0x3f,
	0xb0, 0xb9, 0x6b, 0x2c, 0xed, 0x68, 0xbb, 0x2b, 0x34, 0x19, 0x6e, 0x3d, 0x07, 0xc8, 0xe8, 0x44,
	0x87, 0xe2, 0x35, 0xbb, 0x41, 0xdf, 0x56, 0xa8, 0xf8, 0x24, 0xf7, 0xa0, 0xf4, 0xce, 0x74, 0x22,
	0x86, 0xb6, 0xae, 0x50, 0x39, 0x38, 0x2c, 0x3c, 0xd7, 0x1a, 0xef, 0x35, 0xa8, 0x0d, 0x98, 0xff,
	0xce, 0xb6, 0x58, 0x6c, 0xda, 0x73, 0x28, 0x07, 0x6a, 0x70, 0xd6, 0x13, 0xdb, 0x62, 0x1a, 0x7a,
	0x56, 0x1d, 0x8c, 0x32, 0xd7, 0x62, 0x3e, 0xf9, 0x59, 0xe2, 0x54, 0x01, 0x9d, 0xda, 0x99, 0x99,
	0x18, 0xef, 0xd9, 0xbc, 0x5f, 0x9b, 0x50, 0x0a, 0x2c, 0xee, 0x33, 0xa3, 0xb8, 0xa3, 0xed, 0x16,
	0x0f, 0xb5, 0xc7, 0x54, 0x8e, 0xbf, 0x83, 0x5b, 0x36, 0xc0, 0xc0, 0xe1, 0x61, 0xec, 0xd2, 0xd3,
	0x19, 0x97, 0xf4, 0xd4, 0x32, 0x87, 0x87, 0x72, 0xa7, 0x06, 0xf3, 0xee, 0x3c, 0x80, 0x72, 0xe0,
	0xf0, 0xb0, 0x3b, 0x41, 0xf5, 0xd5, 0x83, 0xda, 0x3e, 0xe6, 0x17, 0x4e, 0xea, 0x4e, 0x68, 0x2c,
	0x6c, 0xfc, 0xa9, 0x0c, 0x15, 0x84, 0x44, 0x7e, 0x11, 0x58, 0xf2, 0xb9, 0xc3, 0x62, 0x23, 0xf1,
	0xfb, 0xff, 0xd4, 0x43, 0xb6, 0x01, 0x7c, 0x66, 0x39, 0xa6, 0x3d, 0xb5, 0xdd, 0x4b, 0x0c, 0x45,
	0x85, 0x2a, 0x08, 0x79, 0x0e, 0xab, 0x82, 0x49, 0x59, 0xc0, 0x23, 0xdf, 0x62, 0x98, 0x02, 0xd5,
	0x83, 0x7b, 0xaa, 0x2b, 0x89, 0x8c, 0xe6, 0x98, 0xe4, 0x10, 0x6a, 0x9e, 0xcf, 0x2d, 0x16, 0x04,
	0x71, 0xc6, 0x96, 0x70, 0x7f, 0xee, 0xc5, 0x76, 0x9c, 0xaa, 0x32, 0x9a, 0xa7, 0x92, 0xa7, 0x50,
	0x0d, 0x1c, 0xf3, 0x5d, 0xbc, 0x79, 0x46, 0x19, 0x17, 0x25, 0xa9, 0x07, 0xa9, 0x84, 0xaa, 0x34,
	0xb2, 0x0b, 0x6b, 0x8e, 0x19, 0xb9, 0xd6, 0xd5, 0xc0, 0xbe, 0x74, 0xcd, 0x30, 0xf2, 0x99, 0x51,
	0x11, 0x7b, 0x4b, 0x67, 0x61, 0xc1, 0xf4, 0x4c, 0xeb, 0xda, 0xbc, 0x64, 0xad, 0x2b, 0x66, 0x5d,
	0x07, 0xd1, 0xd4, 0x58, 0xc1, 0xd8, 0xcd, 0xc2, 0xe8, 0x85, 0x84, 0x62, 0x5b, 0x20, 0x0e, 0x40,
	0xec, 0x85, 0x2a, 0xa3, 0x79, 0x2a, 0x79, 0x06, 0xc4, 0xe5, 0x3d, 0xee, 0x5e, 0x32, 0xff, 0xd8,
	0x0c, 0xad, 0xab, 0x37, 0x11, 0x8b, 0x98, 0x51, 0x13, 0x31, 0x3e, 0x2c, 0x5d, 0x98, 0x4e, 0xc0,
	0xe8, 0x02, 0x02, 0x79, 0x03, 0x3b, 0x39, 0x34, 0x8d, 0x2f, 0xfb, 0x6d, 0x64, 0xfb, 0x6c, 0xca,
	0xdc, 0xd0, 0xa8, 0xab, 0x4a, 0x3e, 0x4a, 0x27, 0x87, 0x60, 0x78, 0x3e, 0x6b, 0x33, 0xcf, 0xe1,
	0x37, 0xa7, 0x33, 0x8e, 0x13, 0x74, 0xfc, 0x56, 0x39, 0xe9, 0xc1, 0xc6, 0xac, 0x2c, 0x0e, 0xc5,
	0xfa, 0xff, 0x08, 0xc5, 0x2d, 0x73, 0xc8, 0x17, 0x50, 0xf3, 0x33, 0xc3, 0xba, 0x13, 0x63, 0x13,
	0x97, 0xcf, 0x83, 0xe4, 0x21, 0x54, 0x3c, 0xdf, 0xe6, 0xbe, 0x1d, 0xde, 0x18, 0x06, 0xae, 0xb2,
	0x96, 0xa6, 0x8d, 0x84, 0x69, 0x4a, 0x68, 0x7c, 0x5b, 0x01, 0x5d, 0xb6, 0xbf, 0x3e, 0x9f, 0xe4,
	0xd6, 0xf1, 0x1c, 0xdb, 0x32, 0x05, 0xd8, 0x9d, 0xc4, 0xb5, 0x91, 0x07, 0x49, 0x23, 0x69, 0xaa,
	0x31, 0x49, 0x56, 0x74, 0x0e, 0x13, 0x15, 0x62, 0x45, 0xfe, 0x28, 0x6e, 0x81, 0x45, 0x64, 0x28,
	0x08, 0xd9, 0x81, 0xaa, 0xcb, 0x7e, 0x1f, 0x8e, 0x72, 0x3d, 0x52, 0x85, 0xc4, 0x2a, 0x17, 0xb6,
	0x6b, 0x3a, 0x09, 0xa5, 0x24, 0x57, 0x51, 0x31, 0xf2, 0x39, 0x2c, 0xf3, 0x8b, 0x0b, 0xc7, 0x76,
	0x19, 0x66, 0x7b, 0xba, 0xb7, 0x09, 0x4a, 0x7e, 0x08, 0x2b, 0x3e, 0x73, 0x98, 0x19, 0x88, 0x3a,
	0x5d, 0x56, 0x29, 0x19, 0x4e, 0x1e, 0xe4, 0xaa, 0xb9, 0xa2, 0xb2, 0xd4, 0xa2, 0x7e, 0x06, 0xc4,
	0x67, 0xe6, 0xe4, 0xe6, 0x15, 0xf7, 0x5b, 0x99, 0x6b, 0x2b, 0xb9, 0xc4, 0x9c, 0x27, 0x90, 0x1f,
	0x40, 0xc5, 0x0e, 0x5e, 0x9a, 0xd6, 0x75, 0xe4, 0x61, 0x19, 0xa4, 0xe4, 0x14, 0x26, 0x5f, 0x81,
	0xee, 0x98, 0x41, 0xd8, 0xe7, 0x21, 0xe6, 0xe2, 0xd0, 0x9e, 0x32, 0xa3, 0x9a, 0xf4, 0xd7, 0x39,
	0x91, 0x42, 0xa7, 0x62, 0x39, 0xa4, 0xaf, 0xce, 0xd2, 0x53, 0x11, 0x79, 0x03, 0x6b, 0xa2, 0xc5,
	0x34, 0x1d, 0x87, 0x5b, 0x71, 0x0e, 0xd6, 0xb0, 0xb5, 0x6e, 0xaa, 0xfd, 0x48, 0x11, 0x1f, 0xd6,
	0x07, 0xcd, 0xc1, 0xf8, 0x6d, 0xbf, 0x39, 0x18, 0x74, 0x8f, 0xfa, 0x9d, 0x36, 0x9d, 0x9d, 0x4f,
	0xbe, 0x84, 0x4a, 0x10, 0xb7, 0x51, 0x2c, 0xaa, 0x6a, 0xbe, 0x4d, 0x0b, 0x9c, 0xa6, 0x0c, 0x72,
	0x00, 0x70, 0x95, 0x9e, 0x95, 0xc6, 0x5a, 0xdc, 0x96, 0xe6, 0x4e, 0x51, 0xaa, 0xb0, 0xc8, 0xcf,
	0xa1, 0x1a, 0xc8, 0xa3, 0x08, 0x27, 0xe9, 0x38, 0xe9, 0xfe, 0xc2, 0x53, 0x8a, 0xaa, 0x4c, 0xb1,
	0x58, 0x90, 0x9e, 0x26, 0xc6, 0xdd, 0xfc, 0x62, 0xd9, 0x39, 0x43, 0x15, 0x16, 0xa9, 0x43, 0xc1,
	0xf6, 0xe2, 0x92, 0x2e, 0xd8, 0x1e, 0xf9, 0x11, 0xd4, 0xa3, 0x80, 0xf9, 0x6d, 0x76, 0x91, 0xec,
	0xf2, 0x3a, 0xca, 0x66, 0x50, 0xd1, 0x10, 0x43, 0xd3, 0xbf, 0x64, 0x61, 0xd6, 0x3a, 0xef, 0xc9,
	0x86, 0x38, 0x03, 0x93, 0x3d, 0xd0, 0x25, 0xd4, 0x8a, 0x82, 0x90, 0x4f, 0xd1, 0xa7, 0xfb, 0x48,
	0x9d, 0xc3, 0x45, 0xe9, 0xc8, 0x52, 0x3a, 0xe6, 0x13, 0x66, 0x6c, 0xc8, 0xd2, 0xc9, 0x10, 0xf2,
	0x02, 0xca, 0x8e, 0x79, 0xce, 0x9c, 0xc0, 0xd8, 0xc4, 0xb3, 0xe1, 0x8b, 0xfc, 0x6d, 0x26, 0x2b,
	0xe7, 0xfd, 0x1e, 0xd2, 0xe4, 0xf9, 0x1d, 0xcf, 0xd9, 0xfa, 0x05, 0x54, 0x15, 0xf8, 0x93, 0x0e,
	0xea, 0x7f, 0x15, 0xe0, 0x2e, 0xcd, 0x3a, 0xc1, 0x27, 0xf5, 0x8c, 0x5f, 0xc2, 0xba, 0x15, 0xf9,
	0xb3, 0x16, 0xc6, 0xa7, 0xac, 0x71, 0x9b, 0x07, 0x74, 0xd1, 0x24, 0x72, 0x0a, 0x1b, 0xe7, 0x58,
	0x38, 0x73, 0xea, 0x8a, 0x1f, 0x51, 0x77, 0xcb, 0x3c, 0xf2, 0x39, 0xac, 0x84, 0xf6, 0x54, 0x8c,
	0xa6, 0x1e, 0xf6, 0x22, 0x2c, 0xa5, 0x0c, 0x5b, 0x90, 0x11, 0xa5, 0x85, 0x19, 0xb1, 0xb8, 0x47,
	0x94, 0x3f, 0xd2, 0x23, 0x1a, 0x67, 0x00, 0x47, 0x0e, 0x3f, 0x37, 0x9d, 0x53, 0xc7, 0x74, 0xc5,
	0x0e, 0x58, 0x3c, 0x72, 0x43, 0x8c, 0x64, 0x89, 0xca, 0x01, 0x79, 0x02, 0xc4, 0x31, 0x43, 0x16,
	0x24, 0x0d, 0x92, 0x9a, 0xa1, 0xcd, 0x31, 0x80, 0xa5, 0xc3, 0xe2, 0x4f, 0x1f, 0x3f, 0xa6, 0x0b,
	0xc4, 0x8d, 0xf7, 0x4b, 0xb0, 0x46, 0xb9, 0x13, 0xfb, 0x39, 0x12, 0x5b, 0x49, 0x36, 0xa0, 0x2c,
	0xee, 0x3a, 0xe9, 0x4e, 0xc5, 0x23, 0x51, 0x39, 0x97, 0xa9, 0x11, 0xf1, 0xce, 0xa4, 0x95, 0x93,
	0x99, 0x47, 0x15, 0x16, 0x19, 0x40, 0x3d, 0xbe, 0xd7, 0xb2, 0x89, 0x00, 0x92, 0x4b, 0xf2, 0xc3,
	0x64, 0xde, 0xcc, 0xe2, 0xfb, 0xa3, 0x1c, 0x5b, 0xa6, 0xe6, 0x8c, 0x0a, 0x91, 0x51, 0x39, 0x57,
	0xe2, 0xd3, 0x21, 0x0f, 0x92, 0x47, 0x50, 0x72, 0xf9, 0x84, 0x25, 0x37, 0xa4, 0xcf, 0xd2, 0x15,
	0x67, 0x33, 0x94, 0x4a, 0xde, 0x82, 0x3d, 0x2c, 0x7f, 0xc2, 0x1e, 0x2e, 0x7f, 0xac, 0xcf, 0x7f,
	0x09, 0x77, 0xa7, 0xb6, 0x2b, 0xdb, 0x59, 0xcb, 0xf4, 0x4c, 0x4b, 0x1c, 0xc3, 0x15, 0xdc, 0xc1,
	0x79, 0x81, 0xf0, 0xd1, 0x9c, 0x7c, 0x13, 0x05, 0x21, 0x9b, 0xb4, 0x70, 0xaf, 0x57, 0x90, 0x99,
	0x07, 0xc9, 0x0b, 0xf8, 0x2c, 0x01, 0x8e, 0xe7, 0x74, 0x03, 0xce, 0xb8, 0x9d, 0xb0, 0xf5, 0x2b,
	0x58, 0x5f, 0x10, 0xee, 0x05, 0x25, 0xff, 0x50, 0x2d, 0x79, 0xa5, 0xcd, 0xe6, 0x66, 0xab, 0x9d,
	0xe0, 0x5b, 0x0d, 0xaa, 0x47, 0x3e, 0x8f, 0xbc, 0xb8, 0x7e, 0x0c, 0x58, 0xbe, 0x14, 0xc3, 0x34,
	0xa7, 0x92, 0x21, 0x79, 0x0a, 0x25, 0x91, 0x5e, 0x49, 0x5e, 0x6c, 0xa7, 0xf9, 0x94, 0xcd, 0xc6,
	0x1c, 0x49, 0x5e, 0x19, 0x48, 0xde, 0x7a, 0x03, 0x90, 0x81, 0x0b, 0x0c, 0xfe, 0x2a, 0x6f, 0xf0,
	0xe6, 0x2d, 0xd9, 0xa6, 0x9a, 0x7c, 0x03, 0x15, 0xca, 0x02, 0x8f, 0xbb, 0x01, 0x23, 0xf7, 0x61,
	0xc9, 0x12, 0xbd, 0x15, 0xeb, 0x4b, 0x54, 0x3a, 0x0e, 0xc9, 0xf7, 0x60, 0x39, 0x88, 0xce, 0x5b,
	0x42, 0x52, 0x48, 0x24, 0x09, 0x22, 0x8c, 0x98, 0x06, 0x97, 0xf1, 0x4d, 0x46, 0x7c, 0x92, 0x1f,
	0xc3, 0xd2, 0xc4, 0x0c, 0x4d, 0x63, 0x09, 0x3d, 0x5b, 0x5f, 0xe0, 0x19, 0x45, 0x42, 0xe3, 0x1c,
	0xea, 0x2d, 0x94, 0x25, 0xd7, 0x30, 0xf2, 0x13, 0xa8, 0x4f, 0xcd, 0x6f, 0xb8, 0x3f, 0x4e, 0xef,
	0x6b, 0xd2, 0x94, 0xc2, 0x93, 0x03, 0x5a, 0x43, 0x49, 0x4a, 0x7d, 0x00, 0xf5, 0xa9, 0xed, 0xaa,
	0xd4, 0x82, 0xcc, 0x14, 0x44, 0x13, 0x5a, 0xa3, 0x03, 0xab, 0xea, 0xab, 0x82, 0x3c, 0x83, 0x9a,
	0xfa, 0xae, 0x10, 0xaf, 0xa9, 0xa2, 0x72, 0x21, 0x4c, 0xaf, 0xbb, 0x79, 0x56, 0xe3, 0xcf, 0x1a,
	0xac, 0x26, 0x23, 0x2c, 0xf0, 0x03, 0x71, 0x81, 0xca, 0xeb, 0x58, 0xfc, 0x8c, 0xc9, 0x68, 0xa2,
	0x7f, 0xe1, 0xf6, 0x27, 0x27, 0x08, 0x0e, 0xc8, 0x81, 0x72, 0x3b, 0x95, 0x7d, 0x7a, 0x23, 0x51,
	0x94, 0x8f, 0x8e, 0x72, 0x49, 0xed, 0x42, 0x2d, 0x97, 0x83, 0xe2, 0x61, 0xe5, 0x2b, 0xe6, 0x61,
	0xd8, 0x14, 0x8b, 0x54, 0xd3, 0x69, 0x8e, 0xb9, 0xf7, 0x57, 0x4d, 0x3e, 0xfd, 0xc4, 0x13, 0x92,
	0xdc, 0x85, 0xda, 0x60, 0x38, 0x3e, 0xfd, 0xfa, 0x68, 0xfc, 0xaa, 0xd9, 0xed, 0x75, 0xda, 0xfa,
	0x1d, 0x52, 0x07, 0xe5, 0x5d, 0xa9, 0x6b, 0xa4, 0x0a, 0xcb, 0x83, 0xe1, 0xb8, 0xdd, 0x69, 0xb6,
	0xf5, 0x02, 0x21, 0x50, 0x17, 0x7c, 0x7a, 0xd2, 0x4a, 0x26, 0x14, 0xc9, 0x06, 0x90, 0x04, 0xa3,
	0x9d, 0xc1, 0xb0, 0x49, 0x87, 0xdd, 0xfe, 0x91, 0xbe, 0x44, 0xd6, 0x61, 0x2d, 0xc5, 0xdf, 0xf6,
	0xfb, 0x02, 0x2c, 0xa9, 0xe4, 0x61, 0x87, 0x1e, 0x77, 0xfb, 0xcd, 0x61, 0xa7, 0xad, 0x97, 0xf7,
	0xda, 0xc9, 0x1f, 0x0f, 0x34, 0xab, 0x0e, 0xca, 0x9f, 0x0c, 0xfd, 0x8e, 0xb0, 0xe1, 0xf5, 0x70,
	0xdc, 0x3b, 0x19, 0x0c, 0x75, 0x8d, 0xac, 0x42, 0xe5, 0xf5, 0x70, 0xdc, 0xec, 0x75, 0x47, 0x1d,
	0xbd, 0x10, 0x8b, 0xd0, 0xbc, 0xe2, 0xde, 0x0b, 0x80, 0xec, 0x4f, 0x86, 0xd0, 0x72, 0xa6, 0x6a,
	0xd1, 0x61, 0xf5, 0x6c, 0x38, 0xee, 0x9f, 0x0c, 0xc7, 0xb4, 0xd3, 0x6c, 0xff, 0x5a, 0xaa, 0x3a,
	0x4b, 0x46, 0x85, 0xbd, 0xdf, 0x40, 0x55, 0xf9, 0x5d, 0x40, 0xd6, 0x40, 0xfd, 0x61, 0xa0, 0xdf,
	0x41, 0x87, 0x10, 0x68, 0x8e, 0x9a, 0xdd, 0x5e, 0xf3, 0x65, 0xaf, 0xa3, 0x6b, 0xe8, 0xd0, 0x68,
	0x38, 0x3e, 0x6d, 0xd2, 0xe1, 0x38, 0xc3, 0x0b, 0x18, 0xd9, 0x91, 0x0a, 0x15, 0xf7, 0xfe, 0x00,
	0x6b, 0x33, 0x17, 0x4c, 0x8c, 0x67, 0xee, 0x8a, 0x29, 0xcd, 0x14, 0x58, 0x8a, 0xa0, 0x99, 0x02,
	0x41, 0xff, 0xa5, 0xe6, 0xe6, 0x60, 0x7c, 0xf2, 0xea, 0x55, 0xaf, 0x8b, 0x51, 0x2d, 0x26, 0x10,
	0xed, 0xf4, 0x3a, 0xcd, 0x81, 0x8c, 0x7e, 0xac, 0x45, 0x42, 0x9d, 0xb6, 0x5e, 0x7a, 0xb9, 0xf1,
	0x8f, 0x0f, 0xdb, 0xda, 0x3f, 0x3f, 0x6c, 0x6b, 0xff, 0xfe, 0xb0, 0xad, 0xfd, 0xed, 0x3f, 0xdb,
	0x77, 0xfe, 0xa8, 0x69, 0x7f, 0xd1, 0xb4, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x63, 0x27, 0x4f,
	0x2e, 0x9f, 0x12, 0x00, 0x00,
}

func (m *HealthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != nil {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Metas) > 0 {
		for k := range m.Metas {
			v := m.Metas[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStatus(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.WorkerStatus != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.WorkerStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.HealthStatus != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.HealthStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.Score))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Metas) > 0 {
		for k := range m.Metas {
			v := m.Metas[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStatus(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlotStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlotStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlotStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SlotId != nil {
		{
			size, err := m.SlotId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlotInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlotInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlotInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Priority != nil {
		{
			size, err := m.Priority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.RequirementId != nil {
		i -= len(*m.RequirementId)
		copy(dAtA[i:], *m.RequirementId)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.RequirementId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.PreDeployPackageStatus != nil {
		{
			size, err := m.PreDeployPackageStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.PreDeployPackageChecksum != nil {
		i -= len(*m.PreDeployPackageChecksum)
		copy(dAtA[i:], *m.PreDeployPackageChecksum)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.PreDeployPackageChecksum)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.NoLongerMatchResourceRequirement != nil {
		i--
		if *m.NoLongerMatchResourceRequirement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.NoLongerMatchQueue != nil {
		i--
		if *m.NoLongerMatchQueue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.PackageStatus != nil {
		{
			size, err := m.PackageStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PackageChecksum != nil {
		i -= len(*m.PackageChecksum)
		copy(dAtA[i:], *m.PackageChecksum)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.PackageChecksum)))
		i--
		dAtA[i] = 0x4a
	}
	if m.LaunchSignature != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.LaunchSignature))
		i--
		dAtA[i] = 0x40
	}
	if m.SlaveStatus != nil {
		{
			size, err := m.SlaveStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProcessStatus) > 0 {
		for iNdEx := len(m.ProcessStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProcessStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SlotResource != nil {
		{
			size, err := m.SlotResource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Reclaiming != nil {
		i--
		if *m.Reclaiming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.SlotId != nil {
		{
			size, err := m.SlotId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Role != nil {
		i -= len(*m.Role)
		copy(dAtA[i:], *m.Role)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.Role)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintStatus(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.WorkerMode != nil {
		i -= len(*m.WorkerMode)
		copy(dAtA[i:], *m.WorkerMode)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.WorkerMode)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.TargetCustomInfo != nil {
		i -= len(*m.TargetCustomInfo)
		copy(dAtA[i:], *m.TargetCustomInfo)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.TargetCustomInfo)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.TargetSignature != nil {
		i -= len(*m.TargetSignature)
		copy(dAtA[i:], *m.TargetSignature)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.TargetSignature)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.UserDefVersion != nil {
		i -= len(*m.UserDefVersion)
		copy(dAtA[i:], *m.UserDefVersion)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.UserDefVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Ip != nil {
		i -= len(*m.Ip)
		copy(dAtA[i:], *m.Ip)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.Ip)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.SlotStatus != nil {
		{
			size, err := m.SlotStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ServiceInfo != nil {
		{
			size, err := m.ServiceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.HealthInfo != nil {
		{
			size, err := m.HealthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SlotInfo != nil {
		{
			size, err := m.SlotInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.SlotAllocStatus != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.SlotAllocStatus))
		i--
		dAtA[i] = 0x68
	}
	if m.LastNotReadyTime != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.LastNotReadyTime))
		i--
		dAtA[i] = 0x60
	}
	if m.LastNotMatchTime != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.LastNotMatchTime))
		i--
		dAtA[i] = 0x58
	}
	if m.IsBackup != nil {
		i--
		if *m.IsBackup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.ReadyForCurVersion != nil {
		i--
		if *m.ReadyForCurVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Reclaiming != nil {
		i--
		if *m.Reclaiming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Releasing != nil {
		i--
		if *m.Releasing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Offline != nil {
		i--
		if *m.Offline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.FinalVersion != nil {
		i -= len(*m.FinalVersion)
		copy(dAtA[i:], *m.FinalVersion)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.FinalVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NextVersion != nil {
		i -= len(*m.NextVersion)
		copy(dAtA[i:], *m.NextVersion)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.NextVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.CurVersion != nil {
		i -= len(*m.CurVersion)
		copy(dAtA[i:], *m.CurVersion)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.CurVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if m.WorkerNodeId != nil {
		i -= len(*m.WorkerNodeId)
		copy(dAtA[i:], *m.WorkerNodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.WorkerNodeId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ReplicaNodeId != nil {
		i -= len(*m.ReplicaNodeId)
		copy(dAtA[i:], *m.ReplicaNodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.ReplicaNodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReadyForCurVersion != nil {
		i--
		if *m.ReadyForCurVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.UserDefVersion != nil {
		i -= len(*m.UserDefVersion)
		copy(dAtA[i:], *m.UserDefVersion)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.UserDefVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TimeStamp != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.TimeStamp))
		i--
		dAtA[i] = 0x20
	}
	if m.BackupWorkerNodeStatus != nil {
		{
			size, err := m.BackupWorkerNodeStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CurWorkerNodeStatus != nil {
		{
			size, err := m.CurWorkerNodeStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ReplicaNodeId != nil {
		i -= len(*m.ReplicaNodeId)
		copy(dAtA[i:], *m.ReplicaNodeId)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.ReplicaNodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LatestVersionRatio != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.LatestVersionRatio))
		i--
		dAtA[i] = 0x10
	}
	if m.Count != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleStatusValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleStatusValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleStatusValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdjustedMinHealthCapacity != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.AdjustedMinHealthCapacity))
		i--
		dAtA[i] = 0x50
	}
	if m.AdjustedCount != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.AdjustedCount))
		i--
		dAtA[i] = 0x48
	}
	if m.MinHealthCapacity != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.MinHealthCapacity))
		i--
		dAtA[i] = 0x40
	}
	if m.ReadyForCurVersion != nil {
		i--
		if *m.ReadyForCurVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.UserDefVersion != nil {
		i -= len(*m.UserDefVersion)
		copy(dAtA[i:], *m.UserDefVersion)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.UserDefVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LatestVersion != nil {
		i -= len(*m.LatestVersion)
		copy(dAtA[i:], *m.LatestVersion)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.LatestVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VersionedPlans) > 0 {
		for k := range m.VersionedPlans {
			v := m.VersionedPlans[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintStatus(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GlobalPlan != nil {
		{
			size, err := m.GlobalPlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RoleId != nil {
		i -= len(*m.RoleId)
		copy(dAtA[i:], *m.RoleId)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.RoleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for k := range m.Roles {
			v := m.Roles[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintStatus(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GroupId != nil {
		i -= len(*m.GroupId)
		copy(dAtA[i:], *m.GroupId)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.GroupId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Msg != nil {
		i -= len(*m.Msg)
		copy(dAtA[i:], *m.Msg)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SubCode != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.SubCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CarbonPriority) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CarbonPriority) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CarbonPriority) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinorPriority != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.MinorPriority))
		i--
		dAtA[i] = 0x10
	}
	if m.MajorPriority != nil {
		i = encodeVarintStatus(dAtA, i, uint64(*m.MajorPriority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SlotResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlotResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlotResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SlotResources) > 0 {
		for iNdEx := len(m.SlotResources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlotResources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourcePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Priority != nil {
		{
			size, err := m.Priority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Group != nil {
		i -= len(*m.Group)
		copy(dAtA[i:], *m.Group)
		i = encodeVarintStatus(dAtA, i, uint64(len(*m.Group)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStatus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VersionedPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionedPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionedPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResourcePlan != nil {
		{
			size, err := m.ResourcePlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStatus(dAtA []byte, offset int, v uint64) int {
	offset -= sovStatus(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HealthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HealthStatus != nil {
		n += 1 + sovStatus(uint64(*m.HealthStatus))
	}
	if m.WorkerStatus != nil {
		n += 1 + sovStatus(uint64(*m.WorkerStatus))
	}
	if len(m.Metas) > 0 {
		for k, v := range m.Metas {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + len(v) + sovStatus(uint64(len(v)))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovStatus(uint64(*m.Status))
	}
	if len(m.Metas) > 0 {
		for k, v := range m.Metas {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + len(v) + sovStatus(uint64(len(v)))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.Score != nil {
		n += 1 + sovStatus(uint64(*m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlotStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += 1 + sovStatus(uint64(*m.Status))
	}
	if m.SlotId != nil {
		l = m.SlotId.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlotInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != nil {
		l = len(*m.Role)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.SlotId != nil {
		l = m.SlotId.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Reclaiming != nil {
		n += 2
	}
	if m.SlotResource != nil {
		l = m.SlotResource.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.ProcessStatus) > 0 {
		for _, e := range m.ProcessStatus {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if m.SlaveStatus != nil {
		l = m.SlaveStatus.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.LaunchSignature != nil {
		n += 1 + sovStatus(uint64(*m.LaunchSignature))
	}
	if m.PackageChecksum != nil {
		l = len(*m.PackageChecksum)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.PackageStatus != nil {
		l = m.PackageStatus.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.NoLongerMatchQueue != nil {
		n += 2
	}
	if m.NoLongerMatchResourceRequirement != nil {
		n += 2
	}
	if m.PreDeployPackageChecksum != nil {
		l = len(*m.PreDeployPackageChecksum)
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.PreDeployPackageStatus != nil {
		l = m.PreDeployPackageStatus.Size()
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.RequirementId != nil {
		l = len(*m.RequirementId)
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.Priority != nil {
		l = m.Priority.Size()
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaNodeId != nil {
		l = len(*m.ReplicaNodeId)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.WorkerNodeId != nil {
		l = len(*m.WorkerNodeId)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.CurVersion != nil {
		l = len(*m.CurVersion)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.NextVersion != nil {
		l = len(*m.NextVersion)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.FinalVersion != nil {
		l = len(*m.FinalVersion)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Offline != nil {
		n += 2
	}
	if m.Releasing != nil {
		n += 2
	}
	if m.Reclaiming != nil {
		n += 2
	}
	if m.ReadyForCurVersion != nil {
		n += 2
	}
	if m.IsBackup != nil {
		n += 2
	}
	if m.LastNotMatchTime != nil {
		n += 1 + sovStatus(uint64(*m.LastNotMatchTime))
	}
	if m.LastNotReadyTime != nil {
		n += 1 + sovStatus(uint64(*m.LastNotReadyTime))
	}
	if m.SlotAllocStatus != nil {
		n += 1 + sovStatus(uint64(*m.SlotAllocStatus))
	}
	if m.SlotInfo != nil {
		l = m.SlotInfo.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.HealthInfo != nil {
		l = m.HealthInfo.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ServiceInfo != nil {
		l = m.ServiceInfo.Size()
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.SlotStatus != nil {
		l = m.SlotStatus.Size()
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.UserDefVersion != nil {
		l = len(*m.UserDefVersion)
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.TargetSignature != nil {
		l = len(*m.TargetSignature)
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.TargetCustomInfo != nil {
		l = len(*m.TargetCustomInfo)
		n += 2 + l + sovStatus(uint64(l))
	}
	if m.WorkerMode != nil {
		l = len(*m.WorkerMode)
		n += 2 + l + sovStatus(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + len(v) + sovStatus(uint64(len(v)))
			n += mapEntrySize + 2 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicaNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaNodeId != nil {
		l = len(*m.ReplicaNodeId)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.CurWorkerNodeStatus != nil {
		l = m.CurWorkerNodeStatus.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.BackupWorkerNodeStatus != nil {
		l = m.BackupWorkerNodeStatus.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.TimeStamp != nil {
		n += 1 + sovStatus(uint64(*m.TimeStamp))
	}
	if m.UserDefVersion != nil {
		l = len(*m.UserDefVersion)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ReadyForCurVersion != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobalPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != nil {
		n += 1 + sovStatus(uint64(*m.Count))
	}
	if m.LatestVersionRatio != nil {
		n += 1 + sovStatus(uint64(*m.LatestVersionRatio))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleStatusValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoleId != nil {
		l = len(*m.RoleId)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.GlobalPlan != nil {
		l = m.GlobalPlan.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.VersionedPlans) > 0 {
		for k, v := range m.VersionedPlans {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStatus(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.LatestVersion != nil {
		l = len(*m.LatestVersion)
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if m.UserDefVersion != nil {
		l = len(*m.UserDefVersion)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ReadyForCurVersion != nil {
		n += 2
	}
	if m.MinHealthCapacity != nil {
		n += 1 + sovStatus(uint64(*m.MinHealthCapacity))
	}
	if m.AdjustedCount != nil {
		n += 1 + sovStatus(uint64(*m.AdjustedCount))
	}
	if m.AdjustedMinHealthCapacity != nil {
		n += 1 + sovStatus(uint64(*m.AdjustedMinHealthCapacity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GroupStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != nil {
		l = len(*m.GroupId)
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Roles) > 0 {
		for k, v := range m.Roles {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStatus(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovStatus(uint64(*m.Code))
	}
	if m.SubCode != nil {
		n += 1 + sovStatus(uint64(*m.SubCode))
	}
	if m.Msg != nil {
		l = len(*m.Msg)
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CarbonPriority) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MajorPriority != nil {
		n += 1 + sovStatus(uint64(*m.MajorPriority))
	}
	if m.MinorPriority != nil {
		n += 1 + sovStatus(uint64(*m.MinorPriority))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SlotResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SlotResources) > 0 {
		for _, e := range m.SlotResources {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if m.Group != nil {
		l = len(*m.Group)
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Priority != nil {
		l = m.Priority.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionedPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourcePlan != nil {
		l = m.ResourcePlan.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStatus(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStatus(x uint64) (n int) {
	return sovStatus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HealthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var v HealthType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= HealthType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HealthStatus = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerStatus", wireType)
			}
			var v WorkerType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= WorkerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WorkerStatus = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metas == nil {
				m.Metas = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metas[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v ServiceType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ServiceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metas == nil {
				m.Metas = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metas[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Score = &v
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlotStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlotStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlotStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v SlotType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SlotType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlotId == nil {
				m.SlotId = &hippo.SlotId{}
			}
			if err := m.SlotId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlotInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlotInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlotInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Role = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlotId == nil {
				m.SlotId = &hippo.SlotId{}
			}
			if err := m.SlotId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reclaiming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reclaiming = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlotResource == nil {
				m.SlotResource = &SlotResource{}
			}
			if err := m.SlotResource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessStatus = append(m.ProcessStatus, &hippo.ProcessStatus{})
			if err := m.ProcessStatus[len(m.ProcessStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlaveStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlaveStatus == nil {
				m.SlaveStatus = &hippo.SlaveStatus{}
			}
			if err := m.SlaveStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaunchSignature", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LaunchSignature = &v
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageChecksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PackageChecksum = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PackageStatus == nil {
				m.PackageStatus = &hippo.PackageStatus{}
			}
			if err := m.PackageStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLongerMatchQueue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NoLongerMatchQueue = &b
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLongerMatchResourceRequirement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NoLongerMatchResourceRequirement = &b
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDeployPackageChecksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PreDeployPackageChecksum = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDeployPackageStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreDeployPackageStatus == nil {
				m.PreDeployPackageStatus = &hippo.PackageStatus{}
			}
			if err := m.PreDeployPackageStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequirementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RequirementId = &s
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Priority == nil {
				m.Priority = &hippo.Priority{}
			}
			if err := m.Priority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ReplicaNodeId = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkerNodeId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CurVersion = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NextVersion = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FinalVersion = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Offline = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Releasing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Releasing = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reclaiming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Reclaiming = &b
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyForCurVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReadyForCurVersion = &b
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBackup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsBackup = &b
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastNotMatchTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastNotMatchTime = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastNotReadyTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastNotReadyTime = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotAllocStatus", wireType)
			}
			var v SlotAllocStatus
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= SlotAllocStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SlotAllocStatus = &v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlotInfo == nil {
				m.SlotInfo = &SlotInfo{}
			}
			if err := m.SlotInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HealthInfo == nil {
				m.HealthInfo = &HealthInfo{}
			}
			if err := m.HealthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceInfo == nil {
				m.ServiceInfo = &ServiceStatus{}
			}
			if err := m.ServiceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlotStatus == nil {
				m.SlotStatus = &SlotStatus{}
			}
			if err := m.SlotStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserDefVersion = &s
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TargetSignature = &s
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCustomInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TargetCustomInfo = &s
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.WorkerMode = &s
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ReplicaNodeId = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurWorkerNodeStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurWorkerNodeStatus == nil {
				m.CurWorkerNodeStatus = &WorkerNodeStatus{}
			}
			if err := m.CurWorkerNodeStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupWorkerNodeStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackupWorkerNodeStatus == nil {
				m.BackupWorkerNodeStatus = &WorkerNodeStatus{}
			}
			if err := m.BackupWorkerNodeStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStamp", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeStamp = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserDefVersion = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyForCurVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReadyForCurVersion = &b
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersionRatio", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LatestVersionRatio = &v
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleStatusValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleStatusValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleStatusValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RoleId = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GlobalPlan == nil {
				m.GlobalPlan = &GlobalPlan{}
			}
			if err := m.GlobalPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionedPlans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionedPlans == nil {
				m.VersionedPlans = make(map[string]*VersionedPlan)
			}
			var mapkey string
			var mapvalue *VersionedPlan
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VersionedPlan{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VersionedPlans[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LatestVersion = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &ReplicaNodeStatus{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserDefVersion = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyForCurVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReadyForCurVersion = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHealthCapacity", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinHealthCapacity = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustedCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdjustedCount = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdjustedMinHealthCapacity", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdjustedMinHealthCapacity = &v
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GroupId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Roles == nil {
				m.Roles = make(map[string]*RoleStatusValue)
			}
			var mapkey string
			var mapvalue *RoleStatusValue
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoleStatusValue{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Roles[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SubCode = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Msg = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &GroupStatus{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CarbonPriority) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CarbonPriority: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CarbonPriority: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MajorPriority", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MajorPriority = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinorPriority", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinorPriority = &v
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlotResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlotResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlotResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlotResources = append(m.SlotResources, &hippo.Resource{})
			if err := m.SlotResources[len(m.SlotResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &SlotResource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Group = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Priority == nil {
				m.Priority = &CarbonPriority{}
			}
			if err := m.Priority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionedPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionedPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionedPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourcePlan == nil {
				m.ResourcePlan = &ResourcePlan{}
			}
			if err := m.ResourcePlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStatus
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStatus
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStatus
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStatus        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatus          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStatus = fmt.Errorf("proto: unexpected end of group")
)
