/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/alibaba/kube-sharding/pkg/apis/carbon/v1/generated.proto

package v1

import (
	fmt "fmt"

	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	k8s_io_api_core_v1 "k8s.io/api/core/v1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

func (m *AllocatorSyncedStatus) Reset()      { *m = AllocatorSyncedStatus{} }
func (*AllocatorSyncedStatus) ProtoMessage() {}
func (*AllocatorSyncedStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{0}
}
func (m *AllocatorSyncedStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorSyncedStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllocatorSyncedStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorSyncedStatus.Merge(m, src)
}
func (m *AllocatorSyncedStatus) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorSyncedStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorSyncedStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorSyncedStatus proto.InternalMessageInfo

func (m *BackupOfPod) Reset()      { *m = BackupOfPod{} }
func (*BackupOfPod) ProtoMessage() {}
func (*BackupOfPod) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{1}
}
func (m *BackupOfPod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupOfPod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BackupOfPod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupOfPod.Merge(m, src)
}
func (m *BackupOfPod) XXX_Size() int {
	return m.Size()
}
func (m *BackupOfPod) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupOfPod.DiscardUnknown(m)
}

var xxx_messageInfo_BackupOfPod proto.InternalMessageInfo

func (m *BroadcastPlan) Reset()      { *m = BroadcastPlan{} }
func (*BroadcastPlan) ProtoMessage() {}
func (*BroadcastPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{2}
}
func (m *BroadcastPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BroadcastPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastPlan.Merge(m, src)
}
func (m *BroadcastPlan) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastPlan.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastPlan proto.InternalMessageInfo

func (m *BrokenRecoverQuotaConfig) Reset()      { *m = BrokenRecoverQuotaConfig{} }
func (*BrokenRecoverQuotaConfig) ProtoMessage() {}
func (*BrokenRecoverQuotaConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{3}
}
func (m *BrokenRecoverQuotaConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BrokenRecoverQuotaConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BrokenRecoverQuotaConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BrokenRecoverQuotaConfig.Merge(m, src)
}
func (m *BrokenRecoverQuotaConfig) XXX_Size() int {
	return m.Size()
}
func (m *BrokenRecoverQuotaConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BrokenRecoverQuotaConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BrokenRecoverQuotaConfig proto.InternalMessageInfo

func (m *ContainerConfig) Reset()      { *m = ContainerConfig{} }
func (*ContainerConfig) ProtoMessage() {}
func (*ContainerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{4}
}
func (m *ContainerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContainerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerConfig.Merge(m, src)
}
func (m *ContainerConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContainerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerConfig proto.InternalMessageInfo

func (m *ContainerHippoExterned) Reset()      { *m = ContainerHippoExterned{} }
func (*ContainerHippoExterned) ProtoMessage() {}
func (*ContainerHippoExterned) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{5}
}
func (m *ContainerHippoExterned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerHippoExterned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ContainerHippoExterned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerHippoExterned.Merge(m, src)
}
func (m *ContainerHippoExterned) XXX_Size() int {
	return m.Size()
}
func (m *ContainerHippoExterned) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerHippoExterned.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerHippoExterned proto.InternalMessageInfo

func (m *Device) Reset()      { *m = Device{} }
func (*Device) ProtoMessage() {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{6}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(m, src)
}
func (m *Device) XXX_Size() int {
	return m.Size()
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

func (m *HealthCondition) Reset()      { *m = HealthCondition{} }
func (*HealthCondition) ProtoMessage() {}
func (*HealthCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{7}
}
func (m *HealthCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HealthCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCondition.Merge(m, src)
}
func (m *HealthCondition) XXX_Size() int {
	return m.Size()
}
func (m *HealthCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCondition.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCondition proto.InternalMessageInfo

func (m *HippoContainer) Reset()      { *m = HippoContainer{} }
func (*HippoContainer) ProtoMessage() {}
func (*HippoContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{8}
}
func (m *HippoContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HippoContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HippoContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HippoContainer.Merge(m, src)
}
func (m *HippoContainer) XXX_Size() int {
	return m.Size()
}
func (m *HippoContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_HippoContainer.DiscardUnknown(m)
}

var xxx_messageInfo_HippoContainer proto.InternalMessageInfo

func (m *HippoPodSpec) Reset()      { *m = HippoPodSpec{} }
func (*HippoPodSpec) ProtoMessage() {}
func (*HippoPodSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{9}
}
func (m *HippoPodSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HippoPodSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HippoPodSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HippoPodSpec.Merge(m, src)
}
func (m *HippoPodSpec) XXX_Size() int {
	return m.Size()
}
func (m *HippoPodSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_HippoPodSpec.DiscardUnknown(m)
}

var xxx_messageInfo_HippoPodSpec proto.InternalMessageInfo

func (m *HippoPodSpecExtendFields) Reset()      { *m = HippoPodSpecExtendFields{} }
func (*HippoPodSpecExtendFields) ProtoMessage() {}
func (*HippoPodSpecExtendFields) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{10}
}
func (m *HippoPodSpecExtendFields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HippoPodSpecExtendFields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HippoPodSpecExtendFields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HippoPodSpecExtendFields.Merge(m, src)
}
func (m *HippoPodSpecExtendFields) XXX_Size() int {
	return m.Size()
}
func (m *HippoPodSpecExtendFields) XXX_DiscardUnknown() {
	xxx_messageInfo_HippoPodSpecExtendFields.DiscardUnknown(m)
}

var xxx_messageInfo_HippoPodSpecExtendFields proto.InternalMessageInfo

func (m *HippoPodTemplate) Reset()      { *m = HippoPodTemplate{} }
func (*HippoPodTemplate) ProtoMessage() {}
func (*HippoPodTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{11}
}
func (m *HippoPodTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HippoPodTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HippoPodTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HippoPodTemplate.Merge(m, src)
}
func (m *HippoPodTemplate) XXX_Size() int {
	return m.Size()
}
func (m *HippoPodTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_HippoPodTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_HippoPodTemplate proto.InternalMessageInfo

func (m *HippoSlotID) Reset()      { *m = HippoSlotID{} }
func (*HippoSlotID) ProtoMessage() {}
func (*HippoSlotID) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{12}
}
func (m *HippoSlotID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HippoSlotID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HippoSlotID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HippoSlotID.Merge(m, src)
}
func (m *HippoSlotID) XXX_Size() int {
	return m.Size()
}
func (m *HippoSlotID) XXX_DiscardUnknown() {
	xxx_messageInfo_HippoSlotID.DiscardUnknown(m)
}

var xxx_messageInfo_HippoSlotID proto.InternalMessageInfo

func (m *PackageInfo) Reset()      { *m = PackageInfo{} }
func (*PackageInfo) ProtoMessage() {}
func (*PackageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{13}
}
func (m *PackageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PackageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackageInfo.Merge(m, src)
}
func (m *PackageInfo) XXX_Size() int {
	return m.Size()
}
func (m *PackageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PackageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PackageInfo proto.InternalMessageInfo

func (m *PodStandbyStatus) Reset()      { *m = PodStandbyStatus{} }
func (*PodStandbyStatus) ProtoMessage() {}
func (*PodStandbyStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{14}
}
func (m *PodStandbyStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodStandbyStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PodStandbyStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodStandbyStatus.Merge(m, src)
}
func (m *PodStandbyStatus) XXX_Size() int {
	return m.Size()
}
func (m *PodStandbyStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_PodStandbyStatus.DiscardUnknown(m)
}

var xxx_messageInfo_PodStandbyStatus proto.InternalMessageInfo

func (m *ServiceCondition) Reset()      { *m = ServiceCondition{} }
func (*ServiceCondition) ProtoMessage() {}
func (*ServiceCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{15}
}
func (m *ServiceCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ServiceCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceCondition.Merge(m, src)
}
func (m *ServiceCondition) XXX_Size() int {
	return m.Size()
}
func (m *ServiceCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceCondition proto.InternalMessageInfo

func (m *SignedVersionPlan) Reset()      { *m = SignedVersionPlan{} }
func (*SignedVersionPlan) ProtoMessage() {}
func (*SignedVersionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{16}
}
func (m *SignedVersionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedVersionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SignedVersionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedVersionPlan.Merge(m, src)
}
func (m *SignedVersionPlan) XXX_Size() int {
	return m.Size()
}
func (m *SignedVersionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedVersionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_SignedVersionPlan proto.InternalMessageInfo

func (m *Ulimit) Reset()      { *m = Ulimit{} }
func (*Ulimit) ProtoMessage() {}
func (*Ulimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{17}
}
func (m *Ulimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ulimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Ulimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ulimit.Merge(m, src)
}
func (m *Ulimit) XXX_Size() int {
	return m.Size()
}
func (m *Ulimit) XXX_DiscardUnknown() {
	xxx_messageInfo_Ulimit.DiscardUnknown(m)
}

var xxx_messageInfo_Ulimit proto.InternalMessageInfo

func (m *VersionPlan) Reset()      { *m = VersionPlan{} }
func (*VersionPlan) ProtoMessage() {}
func (*VersionPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{18}
}
func (m *VersionPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VersionPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionPlan.Merge(m, src)
}
func (m *VersionPlan) XXX_Size() int {
	return m.Size()
}
func (m *VersionPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionPlan.DiscardUnknown(m)
}

var xxx_messageInfo_VersionPlan proto.InternalMessageInfo

func (m *WorkerCondition) Reset()      { *m = WorkerCondition{} }
func (*WorkerCondition) ProtoMessage() {}
func (*WorkerCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{19}
}
func (m *WorkerCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkerCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerCondition.Merge(m, src)
}
func (m *WorkerCondition) XXX_Size() int {
	return m.Size()
}
func (m *WorkerCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerCondition.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerCondition proto.InternalMessageInfo

func (m *WorkerNode) Reset()      { *m = WorkerNode{} }
func (*WorkerNode) ProtoMessage() {}
func (*WorkerNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{20}
}
func (m *WorkerNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkerNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNode.Merge(m, src)
}
func (m *WorkerNode) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNode) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNode.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNode proto.InternalMessageInfo

func (m *WorkerNodeList) Reset()      { *m = WorkerNodeList{} }
func (*WorkerNodeList) ProtoMessage() {}
func (*WorkerNodeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{21}
}
func (m *WorkerNodeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkerNodeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeList.Merge(m, src)
}
func (m *WorkerNodeList) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeList) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeList.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeList proto.InternalMessageInfo

func (m *WorkerNodeSpec) Reset()      { *m = WorkerNodeSpec{} }
func (*WorkerNodeSpec) ProtoMessage() {}
func (*WorkerNodeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{22}
}
func (m *WorkerNodeSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkerNodeSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeSpec.Merge(m, src)
}
func (m *WorkerNodeSpec) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeSpec proto.InternalMessageInfo

func (m *WorkerNodeStatus) Reset()      { *m = WorkerNodeStatus{} }
func (*WorkerNodeStatus) ProtoMessage() {}
func (*WorkerNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{23}
}
func (m *WorkerNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkerNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeStatus.Merge(m, src)
}
func (m *WorkerNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeStatus proto.InternalMessageInfo

func (m *WorkerSchedulePlan) Reset()      { *m = WorkerSchedulePlan{} }
func (*WorkerSchedulePlan) ProtoMessage() {}
func (*WorkerSchedulePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{24}
}
func (m *WorkerSchedulePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerSchedulePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkerSchedulePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerSchedulePlan.Merge(m, src)
}
func (m *WorkerSchedulePlan) XXX_Size() int {
	return m.Size()
}
func (m *WorkerSchedulePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerSchedulePlan.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerSchedulePlan proto.InternalMessageInfo

func (m *WorkerStateChangeRecoder) Reset()      { *m = WorkerStateChangeRecoder{} }
func (*WorkerStateChangeRecoder) ProtoMessage() {}
func (*WorkerStateChangeRecoder) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a7c8fd2a71b56cc, []int{25}
}
func (m *WorkerStateChangeRecoder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerStateChangeRecoder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WorkerStateChangeRecoder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerStateChangeRecoder.Merge(m, src)
}
func (m *WorkerStateChangeRecoder) XXX_Size() int {
	return m.Size()
}
func (m *WorkerStateChangeRecoder) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerStateChangeRecoder.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerStateChangeRecoder proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AllocatorSyncedStatus)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.AllocatorSyncedStatus")
	proto.RegisterType((*BackupOfPod)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.BackupOfPod")
	proto.RegisterType((*BroadcastPlan)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.BroadcastPlan")
	proto.RegisterType((*BrokenRecoverQuotaConfig)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.BrokenRecoverQuotaConfig")
	proto.RegisterType((*ContainerConfig)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.ContainerConfig")
	proto.RegisterType((*ContainerHippoExterned)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.ContainerHippoExterned")
	proto.RegisterMapType((map[string]string)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.ContainerHippoExterned.LabelsEntry")
	proto.RegisterType((*Device)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.Device")
	proto.RegisterType((*HealthCondition)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.HealthCondition")
	proto.RegisterMapType((map[string]string)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.HealthCondition.MetasEntry")
	proto.RegisterType((*HippoContainer)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.HippoContainer")
	proto.RegisterType((*HippoPodSpec)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.HippoPodSpec")
	proto.RegisterType((*HippoPodSpecExtendFields)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.HippoPodSpecExtendFields")
	proto.RegisterType((*HippoPodTemplate)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.HippoPodTemplate")
	proto.RegisterType((*HippoSlotID)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.HippoSlotID")
	proto.RegisterType((*PackageInfo)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.PackageInfo")
	proto.RegisterType((*PodStandbyStatus)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.PodStandbyStatus")
	proto.RegisterType((*ServiceCondition)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.ServiceCondition")
	proto.RegisterType((*SignedVersionPlan)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.SignedVersionPlan")
	proto.RegisterMapType((map[string]string)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.SignedVersionPlan.BufferSelectorEntry")
	proto.RegisterType((*Ulimit)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.Ulimit")
	proto.RegisterType((*VersionPlan)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.VersionPlan")
	proto.RegisterType((*WorkerCondition)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerCondition")
	proto.RegisterType((*WorkerNode)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerNode")
	proto.RegisterType((*WorkerNodeList)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerNodeList")
	proto.RegisterType((*WorkerNodeSpec)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerNodeSpec")
	proto.RegisterType((*WorkerNodeStatus)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerNodeStatus")
	proto.RegisterMapType((map[string]string)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerNodeStatus.RestartRecordsEntry")
	proto.RegisterType((*WorkerSchedulePlan)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerSchedulePlan")
	proto.RegisterType((*WorkerStateChangeRecoder)(nil), "gitlab.alibaba_inc.com.search_infra.c2.pkg.apis.carbon.v1.WorkerStateChangeRecoder")
}

func init() {
	proto.RegisterFile("github.com/alibaba/kube-sharding/pkg/apis/carbon/v1/generated.proto", fileDescriptor_0a7c8fd2a71b56cc)
}

var fileDescriptor_0a7c8fd2a71b56cc = []byte{
	// 4464 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5b, 0xcd, 0x6f, 0x24, 0x49,
	0x56, 0x9f, 0xf2, 0xb7, 0xa3, 0xfc, 0x19, 0xb6, 0x7b, 0x72, 0x3d, 0x33, 0x76, 0xab, 0x06, 0x0d,
	0xcd, 0x6a, 0xb6, 0x3c, 0x63, 0x66, 0x76, 0x67, 0x76, 0xd8, 0xd5, 0xba, 0xca, 0xe5, 0x76, 0xcd,
	0x56, 0xd9, 0xb5, 0xaf, 0xca, 0x6d, 0x1a, 0xf5, 0xe2, 0x4d, 0x67, 0x86, 0xcb, 0x39, 0xce, 0xca,
	0xcc, 0xcd, 0xcc, 0x72, 0x4f, 0x01, 0x83, 0x96, 0x03, 0x7b, 0x02, 0x09, 0x24, 0x10, 0xe2, 0x04,
	0x42, 0xe2, 0xc0, 0x61, 0x91, 0xe0, 0xc4, 0x15, 0x4e, 0x7d, 0x63, 0x8f, 0x2b, 0x21, 0x19, 0xa6,
	0x57, 0xfc, 0x07, 0x9c, 0x7c, 0x42, 0xf1, 0x91, 0x91, 0x11, 0x59, 0x59, 0xfd, 0x31, 0xd5, 0xcb,
	0x81, 0x9b, 0x2b, 0xde, 0xef, 0xbd, 0x88, 0x8c, 0x78, 0xf1, 0xbe, 0xe2, 0x19, 0xd5, 0xbb, 0x4e,
	0xec, 0x9a, 0xe7, 0x65, 0xd3, 0x75, 0xce, 0xcd, 0x73, 0xf3, 0x1b, 0x8e, 0x67, 0x95, 0x2d, 0xbf,
	0xb7, 0x13, 0x11, 0x33, 0xb4, 0x2e, 0xcf, 0x1c, 0xef, 0x22, 0x34, 0x77, 0xac, 0xdd, 0x9d, 0xe0,
	0xaa, 0xbb, 0x63, 0x06, 0x4e, 0xb4, 0x63, 0x99, 0xe1, 0xb9, 0xef, 0xed, 0x5c, 0xbf, 0xbf, 0xd3,
	0x25, 0x1e, 0x09, 0xcd, 0x98, 0xd8, 0xe5, 0x20, 0xf4, 0x63, 0x1f, 0x7f, 0xac, 0x8b, 0x3a, 0x13,
	0xa2, 0xca, 0xaa, 0xa8, 0xb2, 0xb5, 0x5b, 0x0e, 0xae, 0xba, 0x65, 0x2a, 0xaa, 0xcc, 0x45, 0x95,
	0xaf, 0xdf, 0xdf, 0xfc, 0x46, 0xd7, 0x89, 0x2f, 0xfb, 0xe7, 0x6c, 0xe6, 0xae, 0xdf, 0xf5, 0x77,
	0x98, 0xc4, 0xf3, 0xfe, 0x05, 0xfb, 0xc5, 0x7e, 0xb0, 0xbf, 0xf8, 0x4c, 0x9b, 0xa5, 0xab, 0x8f,
	0xa2, 0xb2, 0xe3, 0xd3, 0x05, 0xed, 0x58, 0x7e, 0x48, 0x72, 0x56, 0xb3, 0xf9, 0x41, 0x8a, 0xe9,
	0x99, 0xd6, 0xa5, 0xe3, 0x91, 0x70, 0x90, 0x7e, 0x45, 0x8f, 0xc4, 0x66, 0x0e, 0x57, 0xe9, 0xc9,
	0x22, 0xda, 0xd8, 0x73, 0x5d, 0xdf, 0x32, 0x63, 0x3f, 0x6c, 0x0f, 0x3c, 0x8b, 0xd8, 0xed, 0xd8,
	0x8c, 0xfb, 0x11, 0xde, 0x44, 0x13, 0x4e, 0x60, 0x14, 0xee, 0x16, 0xee, 0xcd, 0x57, 0xd0, 0x93,
	0x9b, 0xed, 0xd7, 0x9e, 0xde, 0x6c, 0x4f, 0xd4, 0x5b, 0x30, 0xe1, 0x04, 0xf8, 0x1d, 0x34, 0x73,
	0xe9, 0x47, 0x71, 0xbd, 0x65, 0x4c, 0x30, 0xfa, 0x92, 0xa0, 0xcf, 0x1c, 0xb2, 0x51, 0x10, 0x54,
	0xfc, 0x09, 0x5a, 0x0c, 0x49, 0xe4, 0xf7, 0x43, 0x8b, 0x34, 0xcd, 0xd8, 0xba, 0x34, 0x26, 0xef,
	0x16, 0xee, 0xcd, 0x55, 0x36, 0x04, 0x7c, 0x11, 0x54, 0x22, 0xe8, 0x58, 0xfc, 0x11, 0x5a, 0x08,
	0x42, 0xdf, 0x22, 0x51, 0xc4, 0x79, 0xa7, 0x18, 0xef, 0xba, 0xe0, 0x5d, 0x68, 0x29, 0x34, 0xd0,
	0x90, 0xf8, 0x11, 0x32, 0x5c, 0x33, 0x8a, 0x13, 0xe9, 0x47, 0x7e, 0xcc, 0xc6, 0x63, 0xa7, 0x47,
	0x8c, 0xe9, 0xbb, 0x85, 0x7b, 0x93, 0x95, 0xbb, 0x42, 0x8a, 0xd1, 0x18, 0x81, 0x83, 0x91, 0x12,
	0xf0, 0x43, 0xf4, 0x3a, 0xa5, 0x89, 0xf9, 0x35, 0xe1, 0x33, 0x4c, 0xf8, 0xb6, 0x10, 0xfe, 0x7a,
	0x23, 0x1f, 0x06, 0xa3, 0xf8, 0xf1, 0x2e, 0x42, 0x21, 0x89, 0x1e, 0x90, 0x30, 0x72, 0x7c, 0xcf,
	0x98, 0x65, 0x7b, 0x8b, 0x85, 0x34, 0x04, 0x92, 0x02, 0x0a, 0x0a, 0xff, 0x06, 0x9a, 0xbd, 0x16,
	0x0c, 0x73, 0x8c, 0x61, 0x59, 0x30, 0xcc, 0x26, 0xe8, 0x84, 0x8e, 0xbf, 0x8b, 0x96, 0xfa, 0x11,
	0x09, 0xf7, 0xc9, 0x45, 0x32, 0xc5, 0x3c, 0xe3, 0xb8, 0x23, 0x38, 0x96, 0x4e, 0x34, 0x2a, 0x64,
	0xd0, 0xca, 0x89, 0xb4, 0xa9, 0x16, 0x1a, 0xe8, 0x6e, 0xe1, 0xde, 0xf4, 0xd0, 0x89, 0x30, 0x1a,
	0x68, 0x48, 0xbc, 0x8b, 0xa6, 0x83, 0x4b, 0x33, 0x22, 0x46, 0x91, 0x4d, 0xf8, 0xa6, 0x60, 0x99,
	0x6e, 0xd1, 0xc1, 0xdb, 0x9b, 0xed, 0xe2, 0xa9, 0x1f, 0x5e, 0x91, 0x90, 0xfd, 0x04, 0x0e, 0xa5,
	0xca, 0x13, 0x98, 0xd6, 0x95, 0xd9, 0x25, 0x5c, 0x23, 0x8d, 0x05, 0xc6, 0x2b, 0x95, 0xa7, 0xa5,
	0x12, 0x41, 0xc7, 0xd2, 0x5d, 0x09, 0x89, 0xe5, 0x9a, 0x4e, 0xcf, 0x58, 0x64, 0x7a, 0x23, 0x77,
	0x05, 0xf8, 0x30, 0x24, 0x74, 0xbc, 0x87, 0x96, 0x1d, 0x2f, 0x26, 0xa1, 0x67, 0xba, 0x82, 0x66,
	0x2c, 0x31, 0x96, 0xd7, 0x05, 0xcb, 0x72, 0x5d, 0x27, 0x43, 0x16, 0xaf, 0x6c, 0x0c, 0x10, 0xd3,
	0x1e, 0x18, 0xcb, 0xb9, 0xaa, 0xca, 0x68, 0xa0, 0x21, 0x71, 0x1b, 0x6d, 0x78, 0x66, 0xcf, 0xf1,
	0xba, 0x40, 0xba, 0x4e, 0x14, 0x93, 0x90, 0xd8, 0x5c, 0xc4, 0x0a, 0x13, 0xf1, 0x96, 0x10, 0xb1,
	0x71, 0x94, 0x07, 0x82, 0x7c, 0x5e, 0xaa, 0x46, 0xc4, 0x8b, 0x9d, 0x78, 0x70, 0x64, 0xf6, 0x88,
	0xb1, 0xaa, 0xab, 0x51, 0x4d, 0x52, 0x40, 0x41, 0xd1, 0xdd, 0xe6, 0xbf, 0x98, 0x35, 0x20, 0xb6,
	0x81, 0xf5, 0xab, 0x5a, 0x53, 0x89, 0xa0, 0x63, 0xe9, 0xf7, 0x27, 0x77, 0xb7, 0xe5, 0xfb, 0xae,
	0xb1, 0xc6, 0xa6, 0x94, 0xdf, 0x0f, 0x0a, 0x0d, 0x34, 0x24, 0xde, 0x47, 0xe8, 0x31, 0x3b, 0xfa,
	0xa6, 0x6f, 0x13, 0x63, 0x9d, 0xf1, 0xfd, 0x5a, 0xb2, 0xd4, 0x53, 0x49, 0xb9, 0xbd, 0xd9, 0x5e,
	0x4a, 0x7f, 0x75, 0x06, 0x01, 0x01, 0x85, 0x6f, 0xf8, 0x4a, 0xb2, 0x7d, 0x60, 0x57, 0x72, 0xe3,
	0x59, 0x57, 0x52, 0xc2, 0x60, 0x14, 0x3f, 0x7e, 0x84, 0x56, 0xfa, 0x9e, 0x19, 0x45, 0x4e, 0xd7,
	0x63, 0xdb, 0x1b, 0xf9, 0x9e, 0x71, 0x87, 0xc9, 0x7c, 0x4f, 0xc8, 0x5c, 0x39, 0xc9, 0xd0, 0x6f,
	0x6f, 0xb6, 0xd7, 0xb3, 0x63, 0x6c, 0xc9, 0x43, 0x92, 0xf0, 0x7d, 0xb4, 0x9a, 0x8e, 0x35, 0x49,
	0x14, 0x99, 0x5d, 0x62, 0xbc, 0xce, 0x76, 0xe1, 0x6b, 0x42, 0xfc, 0xea, 0x49, 0x16, 0x00, 0xc3,
	0x3c, 0xd4, 0xe4, 0x5d, 0x3a, 0x51, 0xec, 0x87, 0x83, 0x21, 0xb8, 0x61, 0x30, 0x79, 0xd2, 0xe4,
	0x1d, 0x8e, 0xc0, 0xc1, 0x48, 0x09, 0xf4, 0x7c, 0x6d, 0xe2, 0x92, 0xd8, 0xf1, 0xbd, 0xaa, 0x1f,
	0xc5, 0xc6, 0xd7, 0xd8, 0x06, 0xc8, 0xf3, 0xdd, 0x57, 0x68, 0xa0, 0x21, 0x29, 0x67, 0x14, 0x9b,
	0x9e, 0x7d, 0x3e, 0x38, 0xf4, 0xfb, 0x61, 0x64, 0x6c, 0xea, 0x9a, 0xd1, 0x56, 0x68, 0xa0, 0x21,
	0xf1, 0x0e, 0x9a, 0xe7, 0x4a, 0x76, 0xe2, 0xd8, 0xc6, 0x1b, 0x8c, 0x6d, 0x55, 0xb0, 0xcd, 0xd7,
	0x12, 0x02, 0xa4, 0x98, 0xd2, 0x11, 0x2a, 0x56, 0x4c, 0xeb, 0xaa, 0x1f, 0x1c, 0x5f, 0xb4, 0x7c,
	0x1b, 0xdf, 0x45, 0x53, 0x1e, 0x55, 0x7f, 0xee, 0xc1, 0x16, 0x04, 0xeb, 0x14, 0x53, 0x7c, 0x46,
	0xc1, 0x6f, 0xa1, 0xc9, 0xbe, 0x63, 0x0b, 0x17, 0x56, 0x14, 0x80, 0x49, 0x2a, 0x95, 0x8e, 0x97,
	0xfe, 0x75, 0x1a, 0x2d, 0x56, 0x42, 0xdf, 0xb4, 0x2d, 0xaa, 0x1a, 0xae, 0xe9, 0xe1, 0xbf, 0x2e,
	0x20, 0xcc, 0xb5, 0xae, 0x6d, 0x5d, 0x12, 0xbb, 0xef, 0x12, 0x3a, 0xcc, 0x66, 0x28, 0xee, 0x36,
	0xcb, 0x5f, 0x39, 0x1c, 0x28, 0x9f, 0x0e, 0x09, 0xad, 0x6c, 0x8a, 0xf5, 0xe0, 0x61, 0x1a, 0xe4,
	0x2c, 0x82, 0xde, 0x79, 0xab, 0x1f, 0xc5, 0x7e, 0xaf, 0xee, 0x5d, 0xf8, 0xe2, 0x9b, 0xe4, 0x9d,
	0xaf, 0x4a, 0x0a, 0x28, 0x28, 0xdc, 0x42, 0xeb, 0x96, 0xdf, 0x0b, 0x42, 0x12, 0x45, 0xc4, 0x4e,
	0x31, 0xcc, 0x4b, 0xa7, 0x46, 0x7a, 0xbd, 0x9a, 0x83, 0x81, 0x5c, 0xce, 0x1c, 0x0f, 0x33, 0xf5,
	0x52, 0x1e, 0xa6, 0x84, 0x66, 0x7c, 0xcf, 0x75, 0x3c, 0xee, 0xa7, 0xe7, 0x2a, 0x88, 0x06, 0x15,
	0xc7, 0x6c, 0x04, 0x04, 0x05, 0x1f, 0x20, 0xdc, 0x0f, 0x6c, 0x33, 0x76, 0xbc, 0xee, 0xfd, 0xd0,
	0xb4, 0xc8, 0x45, 0xdf, 0x75, 0x07, 0xcc, 0xf5, 0xce, 0x55, 0xee, 0xd0, 0x1d, 0x3b, 0x19, 0xa2,
	0x42, 0x0e, 0x07, 0x75, 0x11, 0x41, 0x48, 0x5c, 0xdf, 0xb4, 0x99, 0xa7, 0x55, 0x5c, 0x44, 0x8b,
	0x0f, 0x43, 0x42, 0xc7, 0x1f, 0xa2, 0xa2, 0x13, 0xed, 0x9b, 0xa4, 0xe7, 0x7b, 0x6d, 0x12, 0x33,
	0x3f, 0x3b, 0x57, 0x59, 0x13, 0xf0, 0x62, 0x3d, 0x25, 0x81, 0x8a, 0xc3, 0x4d, 0xb4, 0xc6, 0xe6,
	0x65, 0x27, 0xd4, 0x71, 0x7a, 0x24, 0x8a, 0xcd, 0x5e, 0xc0, 0x9c, 0xee, 0x64, 0xe5, 0x0d, 0xc1,
	0xbe, 0x76, 0x32, 0x0c, 0x81, 0x3c, 0x3e, 0xfc, 0x3e, 0x2a, 0x86, 0xfe, 0x63, 0x7a, 0x1a, 0x2e,
	0x89, 0xb9, 0xf7, 0x9d, 0xab, 0x2c, 0xd3, 0x15, 0x40, 0x3a, 0x0c, 0x2a, 0xa6, 0xf4, 0xd3, 0x02,
	0x32, 0x2a, 0xa1, 0x7f, 0x45, 0x3c, 0x20, 0x96, 0x7f, 0x4d, 0xc2, 0x1f, 0xf4, 0xfd, 0xd8, 0xac,
	0xfa, 0xde, 0x85, 0xd3, 0xc5, 0xdf, 0x46, 0x4b, 0x3d, 0xf3, 0xf3, 0x03, 0xd3, 0x71, 0x89, 0x5d,
	0xf5, 0xfb, 0x5e, 0xcc, 0x34, 0x79, 0xba, 0x82, 0xe9, 0x41, 0x35, 0x35, 0x0a, 0x64, 0x90, 0xb8,
	0x8c, 0x10, 0x35, 0x8f, 0xa7, 0x8e, 0x67, 0xfb, 0x8f, 0x99, 0xba, 0x4d, 0x57, 0x96, 0xa8, 0xaa,
	0x75, 0xe4, 0x28, 0x28, 0x88, 0xd2, 0x93, 0x19, 0xb4, 0x5c, 0xf5, 0xbd, 0xd8, 0xa4, 0x71, 0xa9,
	0x98, 0xdf, 0x45, 0xb3, 0x7d, 0xd7, 0xe9, 0x39, 0x71, 0x64, 0x14, 0xee, 0x4e, 0xde, 0x2b, 0xee,
	0xee, 0x8d, 0x71, 0x85, 0x4e, 0x98, 0xa4, 0xf4, 0x0c, 0xf9, 0xef, 0x08, 0x92, 0x29, 0xa8, 0xa9,
	0x0d, 0xe9, 0x46, 0x86, 0x31, 0xfb, 0x82, 0x06, 0x1d, 0x65, 0x0b, 0x9f, 0x4c, 0x4d, 0x2d, 0x64,
	0x01, 0x30, 0xcc, 0x43, 0xe3, 0x85, 0x28, 0xf6, 0x03, 0xa6, 0x49, 0x2d, 0x12, 0x3a, 0xbe, 0xcd,
	0x2e, 0xcc, 0x64, 0x1a, 0x2f, 0xb4, 0x75, 0x32, 0x64, 0xf1, 0xf8, 0x13, 0xb4, 0x5c, 0x6d, 0x9d,
	0x9c, 0x55, 0x1e, 0x74, 0xce, 0x4e, 0xf7, 0xa0, 0x75, 0x76, 0xd4, 0x16, 0xf7, 0x44, 0x1a, 0xc6,
	0x6a, 0xeb, 0xa4, 0x72, 0x1d, 0x9f, 0x9a, 0x61, 0x70, 0x14, 0x01, 0xfb, 0xf5, 0xa0, 0x43, 0xa1,
	0x47, 0x6d, 0xfc, 0x2d, 0xb4, 0x48, 0x99, 0x1b, 0x8d, 0xea, 0x59, 0x75, 0xaf, 0x7a, 0x58, 0x63,
	0x57, 0x65, 0x3e, 0x55, 0xc7, 0x6a, 0xeb, 0xc4, 0x75, 0xad, 0xaa, 0x69, 0x5d, 0x12, 0xa0, 0x3f,
	0x1a, 0x8d, 0x2a, 0xc3, 0xe1, 0x6f, 0xa2, 0x85, 0xa3, 0x5a, 0xe7, 0xac, 0x05, 0xf5, 0x63, 0xa8,
	0x77, 0x1e, 0xb2, 0x2b, 0xa3, 0xf0, 0x1d, 0x91, 0xb8, 0x15, 0x3a, 0x7e, 0xe8, 0xc4, 0x03, 0x28,
	0x1e, 0xd5, 0x3a, 0x09, 0x0e, 0x7f, 0x0f, 0xad, 0x1c, 0x1d, 0x9f, 0x35, 0x6b, 0xcd, 0xea, 0xfd,
	0x33, 0xa8, 0x55, 0x1b, 0x7b, 0xf5, 0xa6, 0x88, 0x4d, 0xe5, 0xb5, 0x3e, 0xf2, 0x9b, 0xa4, 0x67,
	0x75, 0x93, 0x00, 0x69, 0xe9, 0xe8, 0x98, 0xc1, 0x05, 0x1a, 0x7f, 0x07, 0x2d, 0x37, 0x6b, 0xcd,
	0xb3, 0xd3, 0xe6, 0x1e, 0x7c, 0xff, 0x0c, 0xf6, 0x3a, 0xf5, 0x63, 0x11, 0xab, 0xca, 0xf0, 0xa2,
	0x49, 0x7a, 0xa7, 0x3d, 0x33, 0xbc, 0x02, 0x33, 0x76, 0x7c, 0x58, 0x6c, 0xd6, 0x9a, 0x0c, 0xcc,
	0xb0, 0x09, 0xfb, 0xc1, 0x31, 0x54, 0x6b, 0x67, 0xb5, 0x66, 0xab, 0xf3, 0x50, 0x04, 0xae, 0x2a,
	0xfb, 0x81, 0x1f, 0x5a, 0xa4, 0xd6, 0x0b, 0xe2, 0x01, 0x63, 0x67, 0x60, 0x86, 0x4d, 0xd8, 0x6b,
	0xbf, 0xdd, 0x81, 0xbd, 0xb3, 0xca, 0xc3, 0x4e, 0xad, 0xcd, 0xee, 0x8e, 0xce, 0x5e, 0xfb, 0x3c,
	0x0e, 0xcd, 0xca, 0x20, 0x26, 0x11, 0x63, 0x67, 0x60, 0x86, 0xd5, 0xd9, 0xf9, 0xe2, 0x8b, 0xf9,
	0xec, 0xe9, 0xe2, 0x19, 0x98, 0x2f, 0xfe, 0x18, 0x6d, 0xb4, 0xa0, 0xb6, 0x5f, 0xaf, 0x76, 0xce,
	0xf6, 0x6b, 0x8d, 0xbd, 0x87, 0x67, 0xed, 0x5a, 0xf5, 0xf8, 0x68, 0xbf, 0x2d, 0xc2, 0x59, 0x69,
	0x06, 0x5a, 0x21, 0xb1, 0x1d, 0x2b, 0xde, 0x27, 0xae, 0x39, 0x68, 0x13, 0xcb, 0xf7, 0xec, 0x08,
	0xd6, 0x04, 0x27, 0x63, 0x14, 0x7c, 0xa5, 0x7f, 0x9b, 0x42, 0x77, 0xe4, 0x55, 0x3a, 0x74, 0x82,
	0xc0, 0xaf, 0x7d, 0x4e, 0xc3, 0x51, 0x62, 0xe3, 0xdf, 0x47, 0x33, 0x0d, 0xf3, 0x9c, 0xb8, 0xc9,
	0x85, 0xfa, 0xe1, 0x18, 0x17, 0x2a, 0x7f, 0x8a, 0x32, 0x97, 0x5f, 0xf3, 0xe2, 0x70, 0x50, 0x99,
	0xa2, 0x6b, 0x07, 0x31, 0x25, 0x7e, 0x17, 0x2d, 0xb5, 0x42, 0xb2, 0x4f, 0x02, 0xd7, 0x1f, 0xd4,
	0x7b, 0x34, 0xf0, 0xe0, 0x5e, 0x88, 0xa3, 0x32, 0x34, 0xfc, 0x5b, 0x08, 0xd1, 0x64, 0x91, 0x9b,
	0x02, 0x76, 0x81, 0x16, 0x2a, 0x6f, 0xde, 0xde, 0x6c, 0x1b, 0xc4, 0xb3, 0x7c, 0xdb, 0xf1, 0xba,
	0x3b, 0x9f, 0x45, 0xbe, 0x57, 0x06, 0xf3, 0x71, 0x12, 0x9e, 0x28, 0x78, 0x6a, 0x3a, 0x6c, 0x72,
	0xed, 0x58, 0x24, 0x32, 0xa6, 0xc6, 0x36, 0x1d, 0xfb, 0x4c, 0x52, 0x6a, 0x3a, 0xf8, 0xef, 0x08,
	0x92, 0x29, 0xf0, 0x8f, 0xd1, 0xac, 0xc5, 0xe6, 0x8d, 0xd8, 0x5d, 0x2b, 0xee, 0x7e, 0xfa, 0x2a,
	0xf6, 0x95, 0x7f, 0x4a, 0xa5, 0x48, 0xa7, 0xe4, 0x7f, 0x47, 0x90, 0xcc, 0x83, 0xdf, 0x46, 0xd3,
	0xa6, 0xeb, 0x98, 0x91, 0xb8, 0xa4, 0x8b, 0x49, 0xc2, 0xb4, 0x47, 0x07, 0x81, 0xd3, 0x36, 0x3f,
	0x46, 0x45, 0xe5, 0x38, 0xf0, 0x0a, 0x9a, 0xbc, 0x22, 0x03, 0x1e, 0xf0, 0x00, 0xfd, 0x13, 0xaf,
	0xa3, 0xe9, 0x6b, 0xd3, 0xed, 0x8b, 0x93, 0x00, 0xfe, 0xe3, 0xdb, 0x13, 0x1f, 0x15, 0x4a, 0x4f,
	0x0a, 0x68, 0x86, 0x7f, 0x27, 0x8d, 0x1c, 0x02, 0x33, 0xbe, 0x3c, 0xf6, 0xe8, 0xfe, 0x8a, 0x70,
	0x49, 0x46, 0x0e, 0x2d, 0x49, 0x01, 0x05, 0x45, 0x6d, 0x20, 0xfd, 0x55, 0xf7, 0xe4, 0xd7, 0x88,
	0xc3, 0x96, 0x36, 0xb0, 0xa5, 0x93, 0x21, 0x8b, 0xa7, 0xf6, 0xd8, 0xea, 0x86, 0x7e, 0x3f, 0x68,
	0x91, 0xb0, 0xe7, 0x44, 0xd4, 0xfd, 0x47, 0x22, 0xf2, 0x90, 0xf6, 0xb8, 0x9a, 0x05, 0xc0, 0x30,
	0x4f, 0xe9, 0xdf, 0x67, 0xd0, 0xf2, 0x21, 0x31, 0xdd, 0xf8, 0xb2, 0xea, 0x7b, 0xb6, 0x43, 0x43,
	0x4f, 0xfc, 0x2d, 0x34, 0x15, 0x0f, 0x82, 0x24, 0xf8, 0x7b, 0x3b, 0x09, 0xfe, 0x68, 0x14, 0x7e,
	0x7b, 0xb3, 0xbd, 0x96, 0x81, 0xb3, 0xe0, 0x9c, 0x31, 0xe0, 0x6f, 0xa2, 0x99, 0x88, 0x67, 0x9b,
	0xfc, 0x7b, 0xb6, 0x92, 0xca, 0x06, 0xcf, 0x2b, 0x6f, 0x6f, 0xb6, 0x17, 0x38, 0xb3, 0x48, 0x3b,
	0x05, 0x1a, 0x5f, 0x23, 0x4c, 0x33, 0x88, 0x4e, 0x68, 0x7a, 0x11, 0x97, 0x49, 0x93, 0x8f, 0x49,
	0xa6, 0x2d, 0x5f, 0x2f, 0xf3, 0xd2, 0x4c, 0x59, 0x2d, 0xcd, 0xa4, 0xaa, 0xd1, 0x23, 0xb1, 0x49,
	0x15, 0x83, 0x72, 0xa4, 0x61, 0x5f, 0x63, 0x48, 0x1a, 0xe4, 0xcc, 0x80, 0xdf, 0x41, 0x33, 0x21,
	0x4f, 0x4a, 0xa6, 0xf4, 0x4a, 0x0c, 0x4f, 0x30, 0x40, 0x50, 0x69, 0xb0, 0xd3, 0x13, 0xe9, 0xc0,
	0xb4, 0x5e, 0x25, 0x48, 0xae, 0x57, 0x42, 0xa7, 0x21, 0x3b, 0x9d, 0xa8, 0xe1, 0x47, 0x71, 0x27,
	0x2d, 0x6a, 0x48, 0xcf, 0xd4, 0x50, 0x68, 0xa0, 0x21, 0x69, 0xc8, 0xee, 0xb2, 0x3b, 0x4a, 0x63,
	0x89, 0x59, 0x16, 0x13, 0xc8, 0x90, 0xbd, 0x91, 0x10, 0x20, 0xc5, 0xe0, 0xdf, 0x43, 0xd3, 0xf4,
	0xeb, 0x23, 0x63, 0x8e, 0x5d, 0xe2, 0x93, 0x31, 0xae, 0x55, 0xe6, 0x48, 0xcb, 0x4d, 0x2a, 0x97,
	0x9b, 0x29, 0x79, 0x79, 0xd8, 0x18, 0xf0, 0x29, 0xe9, 0x8e, 0x58, 0x97, 0xc4, 0xba, 0x22, 0x36,
	0x73, 0x26, 0x4a, 0xf8, 0x57, 0xe5, 0xc3, 0x90, 0xd0, 0xa9, 0xb6, 0xa7, 0xd1, 0x2e, 0x13, 0x22,
	0x1c, 0x88, 0xd4, 0xf6, 0xaa, 0x4e, 0x86, 0x2c, 0x5e, 0xad, 0xd2, 0x14, 0x9f, 0x53, 0xa5, 0x39,
	0x40, 0x0b, 0x22, 0xbe, 0x57, 0xcb, 0x1e, 0xa5, 0x64, 0xff, 0x4f, 0x15, 0xda, 0xad, 0x4c, 0x92,
	0x99, 0x0a, 0x6b, 0x7c, 0x9b, 0x1f, 0x21, 0x94, 0x6e, 0xc2, 0x4b, 0x19, 0x87, 0x3f, 0x99, 0x40,
	0x4b, 0xcc, 0xea, 0xa7, 0xb7, 0xf5, 0x08, 0xcd, 0x5b, 0xf2, 0xaa, 0xf3, 0x84, 0xe7, 0x2d, 0x45,
	0xad, 0xcb, 0x96, 0x1f, 0x12, 0xcd, 0xba, 0xa5, 0x27, 0x9f, 0xda, 0x80, 0x54, 0x04, 0xfe, 0x87,
	0x02, 0xba, 0x63, 0xe5, 0x7a, 0x18, 0xb6, 0x9c, 0xe2, 0xee, 0x0f, 0x5e, 0xb9, 0xeb, 0x92, 0x77,
	0x79, 0x84, 0xf7, 0x84, 0x11, 0x0b, 0x2a, 0xfd, 0xc7, 0x24, 0x5a, 0x60, 0x23, 0x2d, 0xdf, 0x6e,
	0x07, 0xc4, 0xc2, 0x07, 0x68, 0x36, 0xe0, 0x7f, 0x8a, 0xad, 0x78, 0x23, 0x6f, 0x2b, 0x04, 0x5a,
	0x49, 0x2b, 0xf8, 0x00, 0x24, 0xcc, 0xf8, 0x0b, 0x84, 0xe4, 0x94, 0xd4, 0xe0, 0xd0, 0x3b, 0x50,
	0x1f, 0xe7, 0x0e, 0x68, 0x67, 0xa6, 0xa4, 0x7f, 0x72, 0x12, 0x50, 0x26, 0xc4, 0xff, 0x54, 0x40,
	0xc6, 0xa5, 0xf2, 0x5d, 0xf4, 0x83, 0x3d, 0xfb, 0xc0, 0x21, 0xae, 0x1d, 0x09, 0xd3, 0xd5, 0x1e,
	0x77, 0x35, 0x39, 0xa2, 0xd5, 0x4a, 0x44, 0x3e, 0x02, 0x46, 0x2e, 0x0b, 0xb7, 0xd0, 0x02, 0xa3,
	0x3d, 0xf0, 0xdd, 0x7e, 0x4f, 0x78, 0xff, 0x85, 0xca, 0xbb, 0xf4, 0x62, 0x1c, 0x2a, 0xe3, 0xcf,
	0x0c, 0x24, 0x34, 0x09, 0xa5, 0xbf, 0x9a, 0x42, 0x23, 0x17, 0xc2, 0xb2, 0xea, 0xa0, 0x1f, 0x91,
	0x98, 0x95, 0xa7, 0x32, 0xbe, 0xb1, 0x2a, 0x29, 0xa0, 0xa0, 0x68, 0x9a, 0x66, 0x05, 0xfd, 0xf6,
	0xa5, 0x19, 0x92, 0xa3, 0x7e, 0x4f, 0xe4, 0x46, 0xcb, 0x22, 0x32, 0x4f, 0x86, 0x41, 0xc5, 0xd0,
	0xb4, 0x59, 0x9e, 0x0b, 0x95, 0xe1, 0x0a, 0x47, 0x28, 0xe3, 0xeb, 0xaa, 0x46, 0x85, 0x0c, 0x1a,
	0xff, 0xa4, 0x80, 0x16, 0x44, 0xfd, 0x93, 0xa6, 0xe1, 0x49, 0x50, 0x74, 0x30, 0xc6, 0xe9, 0xb5,
	0x52, 0x71, 0x4a, 0x21, 0x53, 0x99, 0x03, 0xb4, 0x19, 0xf1, 0x3e, 0x5a, 0x09, 0x94, 0x08, 0xb6,
	0x93, 0xd6, 0xda, 0x8d, 0xa4, 0x4e, 0xd6, 0xca, 0xd0, 0x61, 0x88, 0x03, 0x37, 0xd0, 0xba, 0x48,
	0xb8, 0x4e, 0x9d, 0xf8, 0xd2, 0xef, 0xc7, 0x40, 0x7a, 0xfe, 0x35, 0x11, 0xd9, 0xbd, 0xf1, 0xf4,
	0x66, 0x7b, 0x1d, 0x72, 0xe8, 0x90, 0xcb, 0x45, 0x23, 0x77, 0x8f, 0x10, 0x9b, 0x9d, 0x6e, 0x93,
	0x3a, 0x9c, 0x48, 0x64, 0xfa, 0x6b, 0xd4, 0x66, 0x1f, 0xe9, 0x24, 0xc8, 0x62, 0x4b, 0xff, 0x59,
	0x40, 0x2b, 0x89, 0x66, 0x74, 0x48, 0x2f, 0x70, 0xcd, 0x98, 0xe0, 0x1f, 0xa1, 0x39, 0xea, 0x3f,
	0x6c, 0x33, 0x36, 0xc5, 0xe5, 0x7f, 0xef, 0xc5, 0xdc, 0xfb, 0xf1, 0xf9, 0x67, 0xc4, 0x8a, 0xa9,
	0x45, 0x4e, 0x35, 0x28, 0x1d, 0x03, 0x29, 0x15, 0x3b, 0x68, 0x2a, 0xa2, 0xa6, 0x85, 0xdb, 0xc1,
	0xfb, 0xaf, 0xe8, 0x06, 0xa6, 0x15, 0x30, 0x66, 0x83, 0xd8, 0x14, 0xa5, 0x1f, 0xa3, 0x22, 0xc3,
	0xb4, 0x5d, 0x3f, 0xae, 0xef, 0xe3, 0x8f, 0xd1, 0x62, 0xe4, 0x9a, 0xd7, 0xe4, 0xcc, 0xb4, 0x6d,
	0xea, 0xbc, 0x84, 0xc2, 0xa7, 0xd5, 0x3a, 0x4a, 0xdc, 0xe3, 0x34, 0x58, 0x88, 0x94, 0x5f, 0xf8,
	0xd7, 0xd1, 0x6c, 0xe4, 0xfa, 0xf1, 0x99, 0xa8, 0xa7, 0x4d, 0xa6, 0x81, 0x08, 0x97, 0x0d, 0x33,
	0x94, 0x5c, 0xb7, 0x4b, 0x9f, 0xa3, 0xa2, 0xa2, 0x45, 0xf8, 0x43, 0x54, 0x0c, 0x4c, 0xcb, 0xbc,
	0xea, 0xb2, 0xa2, 0xae, 0x98, 0x50, 0xa6, 0xa4, 0xad, 0x94, 0x04, 0x2a, 0x8e, 0xc7, 0xac, 0x4c,
	0xca, 0x49, 0xe8, 0x64, 0xab, 0x5d, 0x42, 0xfe, 0x09, 0xd4, 0x41, 0x41, 0x95, 0xae, 0xd1, 0x0a,
	0xdd, 0x0b, 0x5e, 0x63, 0x14, 0xcf, 0x04, 0xef, 0xa2, 0xb9, 0x7e, 0x44, 0x8e, 0x43, 0x5b, 0x78,
	0xb5, 0xc9, 0xca, 0x8a, 0x90, 0x32, 0x77, 0x22, 0xc6, 0x41, 0x22, 0xf0, 0x07, 0x99, 0x62, 0x26,
	0xb5, 0xd8, 0x93, 0x95, 0x95, 0x67, 0x17, 0x32, 0x4b, 0x7f, 0x37, 0x8d, 0x56, 0xda, 0x24, 0xa4,
	0xb1, 0x76, 0x1a, 0xa0, 0xbe, 0xa7, 0x05, 0xa8, 0x6f, 0x66, 0x02, 0xd4, 0x05, 0x5e, 0xd1, 0x0f,
	0x07, 0x4a, 0x64, 0xfa, 0x21, 0x2a, 0x46, 0x5c, 0x0a, 0xab, 0xea, 0x4f, 0xe8, 0x3b, 0xd5, 0x4e,
	0x49, 0xa0, 0xe2, 0x70, 0x43, 0x06, 0xb4, 0xdc, 0xa4, 0x7c, 0x30, 0x14, 0xd0, 0xe6, 0x3c, 0x2e,
	0x96, 0xe5, 0x42, 0x33, 0x61, 0xee, 0xdb, 0x68, 0x3a, 0x62, 0x4f, 0x3f, 0x53, 0x6c, 0xb3, 0x64,
	0x64, 0xc5, 0xdf, 0x7c, 0x38, 0x6d, 0x44, 0x2c, 0x3c, 0xfd, 0x7f, 0x18, 0x0b, 0xcf, 0xbc, 0x68,
	0x2c, 0x3c, 0xfb, 0x9c, 0x58, 0xf8, 0x5d, 0x34, 0xe7, 0x78, 0xa7, 0x66, 0xd8, 0xeb, 0x07, 0xa2,
	0xea, 0x27, 0xf5, 0xa3, 0x2e, 0xc6, 0x41, 0x22, 0xe8, 0x11, 0xb1, 0xe2, 0x37, 0xe1, 0x11, 0x30,
	0xaf, 0xf3, 0xc9, 0x23, 0xda, 0x4f, 0x49, 0xa0, 0xe2, 0x64, 0xa5, 0x1a, 0x8d, 0xac, 0x54, 0xd3,
	0xb3, 0x67, 0xe6, 0x8d, 0xaf, 0xa4, 0xa8, 0xd7, 0x1f, 0xdb, 0x29, 0x09, 0x54, 0x9c, 0x1a, 0x74,
	0x2e, 0x3c, 0x3b, 0xe8, 0x2c, 0xfd, 0xd1, 0x34, 0x5a, 0x6d, 0xb3, 0x9a, 0xbf, 0x20, 0xb1, 0xa2,
	0xf2, 0x7d, 0xb4, 0x1a, 0x5d, 0x9a, 0xa1, 0x7d, 0x9f, 0xe6, 0x5c, 0x49, 0x45, 0xb7, 0xa0, 0xe7,
	0x68, 0xed, 0x2c, 0x00, 0x86, 0x79, 0x70, 0x1f, 0xcd, 0xc5, 0xc2, 0x82, 0x0a, 0xbb, 0xf6, 0xfd,
	0x57, 0x60, 0xd7, 0x12, 0xa3, 0x5c, 0x59, 0xa0, 0x07, 0x92, 0xfc, 0x02, 0x39, 0x15, 0x4d, 0x48,
	0x22, 0xa7, 0xeb, 0x99, 0x71, 0x3f, 0x24, 0x42, 0xff, 0x65, 0x58, 0xda, 0x4e, 0x08, 0x90, 0x62,
	0xf0, 0xef, 0xa2, 0x4d, 0xe1, 0x49, 0xf6, 0x2e, 0x62, 0x12, 0x26, 0x0f, 0x57, 0xd5, 0x4b, 0xd3,
	0xeb, 0x12, 0xf1, 0x02, 0xbd, 0xf5, 0xf4, 0x66, 0x7b, 0x13, 0x46, 0xa2, 0xe0, 0x19, 0x12, 0xf0,
	0xdf, 0x16, 0xd0, 0xd2, 0x79, 0xff, 0xe2, 0x82, 0x84, 0x6d, 0xe2, 0x12, 0x2b, 0xf6, 0x43, 0x63,
	0x9a, 0xb9, 0xea, 0x1f, 0x8d, 0xb1, 0x1d, 0x43, 0xe7, 0x56, 0xae, 0x68, 0x53, 0xf0, 0x2c, 0x48,
	0xc6, 0x12, 0x3a, 0x11, 0x32, 0xeb, 0xa1, 0xba, 0x66, 0xf5, 0x76, 0x3b, 0x7e, 0xe0, 0xb3, 0xb7,
	0x80, 0x4c, 0x91, 0xb0, 0x9a, 0x92, 0x40, 0xc5, 0x6d, 0xee, 0xa1, 0xb5, 0x9c, 0x59, 0x5f, 0x2a,
	0xed, 0x78, 0x80, 0x66, 0x78, 0xd5, 0x16, 0x1b, 0x88, 0x69, 0xbf, 0x50, 0x35, 0x5e, 0x40, 0x62,
	0x23, 0x94, 0xd2, 0xf6, 0x2f, 0x92, 0xc2, 0xad, 0xa0, 0xd0, 0x11, 0x4a, 0x39, 0x34, 0xc3, 0xa4,
	0x16, 0x2b, 0x28, 0x74, 0xa4, 0xf4, 0xb3, 0x09, 0x54, 0x54, 0xb5, 0xfa, 0x2f, 0x0b, 0x68, 0x35,
	0xca, 0xee, 0x99, 0x70, 0xe6, 0x8d, 0x57, 0x79, 0x0e, 0xca, 0x25, 0xc9, 0x92, 0x60, 0x78, 0x05,
	0xf8, 0x8f, 0x0b, 0x68, 0xf1, 0x5c, 0x7d, 0x70, 0x12, 0x57, 0xe5, 0x70, 0x8c, 0x35, 0x69, 0x0f,
	0x58, 0x69, 0xc5, 0x52, 0x1b, 0x06, 0x7d, 0xd6, 0xd2, 0x2f, 0x27, 0xd0, 0x32, 0xcf, 0x2a, 0x5f,
	0xb8, 0xa0, 0x92, 0x81, 0x2b, 0x6e, 0xab, 0x91, 0x29, 0xa8, 0x8c, 0xe7, 0x7f, 0xfe, 0xff, 0x94,
	0x59, 0x4a, 0xff, 0x38, 0x89, 0x44, 0xee, 0x7e, 0x44, 0xb3, 0x86, 0x47, 0x68, 0x8e, 0xee, 0x17,
	0x8d, 0x05, 0x85, 0x2a, 0x96, 0x5f, 0xf0, 0x7b, 0x04, 0x57, 0xea, 0x99, 0x92, 0x11, 0x90, 0x12,
	0xb5, 0xa8, 0x75, 0xe2, 0x57, 0x12, 0xb5, 0x5e, 0x89, 0xa8, 0x95, 0x9f, 0x45, 0x7d, 0xec, 0xc7,
	0x50, 0xba, 0x29, 0xa3, 0xe2, 0x56, 0x1c, 0x49, 0xa5, 0x9a, 0x1a, 0xdb, 0x99, 0x28, 0xd3, 0x31,
	0x91, 0x4a, 0xe4, 0xaa, 0xe9, 0x5e, 0xe9, 0x5f, 0x26, 0xd0, 0x52, 0x0a, 0x6e, 0x38, 0x51, 0xfc,
	0x2b, 0x3e, 0xb4, 0x47, 0x43, 0x87, 0xf6, 0x82, 0xd2, 0xe9, 0xda, 0x74, 0xe9, 0xc9, 0x88, 0x72,
	0x60, 0x9f, 0xa1, 0x69, 0x27, 0x26, 0x3d, 0x1a, 0x17, 0x52, 0x07, 0x54, 0x7b, 0x25, 0x5b, 0x98,
	0x46, 0x84, 0x75, 0x2a, 0x1b, 0xf8, 0x14, 0xa5, 0xff, 0x99, 0x55, 0xb7, 0x8e, 0xd5, 0x3e, 0x7e,
	0x88, 0xe6, 0xa2, 0xc4, 0x05, 0xf2, 0xad, 0xfb, 0xcd, 0x17, 0xfc, 0x38, 0xf3, 0x9c, 0xb8, 0x89,
	0x93, 0xe1, 0x9e, 0x5f, 0xfa, 0x32, 0x29, 0x32, 0xd3, 0x49, 0x35, 0xf1, 0xb2, 0x9d, 0x54, 0x93,
	0xcf, 0xa9, 0xd1, 0x7d, 0x81, 0x8a, 0xd7, 0x8a, 0xef, 0xe0, 0x5a, 0x38, 0x4e, 0xba, 0xad, 0x7a,
	0x0d, 0xe9, 0x6c, 0x55, 0x7f, 0xa1, 0xce, 0x97, 0xe9, 0x9a, 0x99, 0xfe, 0x8a, 0x5d, 0x33, 0xdf,
	0x41, 0xcb, 0x36, 0x09, 0x88, 0x67, 0x13, 0xcf, 0x1a, 0xf0, 0xae, 0xa3, 0x99, 0x34, 0x3d, 0xde,
	0xd7, 0x49, 0x90, 0xc5, 0xd2, 0xd8, 0x38, 0xf6, 0x79, 0x50, 0x2b, 0xd2, 0xea, 0x54, 0x99, 0xc5,
	0x38, 0x48, 0x04, 0x0d, 0xc5, 0x42, 0xe2, 0x12, 0x33, 0x72, 0xbc, 0xae, 0x08, 0xa5, 0x65, 0x28,
	0x06, 0x09, 0x01, 0x52, 0x8c, 0xda, 0xc1, 0x35, 0xff, 0xfc, 0x0e, 0x2e, 0xff, 0xb1, 0x47, 0xc2,
	0xfb, 0xbc, 0xb9, 0x91, 0x1e, 0x20, 0xd2, 0x5f, 0x64, 0x8f, 0x75, 0x32, 0x64, 0xf1, 0x43, 0x1d,
	0x4c, 0xc5, 0x17, 0xee, 0x60, 0xca, 0xf6, 0xc6, 0x2c, 0x7c, 0xe5, 0xde, 0x98, 0xc5, 0x17, 0xee,
	0x8d, 0xf9, 0x02, 0x15, 0xcf, 0xd3, 0x56, 0x17, 0xd6, 0xae, 0x36, 0x9e, 0xfa, 0x29, 0x8d, 0x33,
	0xa9, 0xfa, 0x29, 0x83, 0xa0, 0xce, 0x47, 0xbd, 0xa1, 0x13, 0xb5, 0x03, 0x3f, 0x16, 0x8d, 0x6e,
	0xd2, 0x62, 0xd6, 0xd9, 0x28, 0x08, 0x6a, 0xe9, 0x9f, 0x37, 0xd0, 0x4a, 0xd6, 0xbc, 0xe2, 0xbf,
	0x2f, 0xa0, 0x0d, 0x33, 0xaf, 0xe3, 0x54, 0x98, 0x81, 0xd6, 0x18, 0x9f, 0x91, 0xdb, 0xc9, 0x9a,
	0x36, 0xd1, 0xe5, 0x92, 0x21, 0x7f, 0x35, 0xf8, 0xbb, 0x68, 0x49, 0xe4, 0xd1, 0xc7, 0x17, 0x17,
	0xac, 0x25, 0x65, 0x82, 0xb7, 0x98, 0x24, 0x71, 0x74, 0x5b, 0xa3, 0x42, 0x06, 0x4d, 0x37, 0xe9,
	0x31, 0x4f, 0xd7, 0x26, 0xf5, 0x4d, 0x12, 0x99, 0x9a, 0xa0, 0x6a, 0x29, 0xe6, 0xd4, 0x73, 0x53,
	0xcc, 0x5d, 0x84, 0x3c, 0x42, 0x6c, 0x81, 0xe7, 0x4d, 0x32, 0xd2, 0xae, 0x1d, 0x49, 0x0a, 0x28,
	0x28, 0xca, 0xe3, 0x78, 0x49, 0x53, 0x8c, 0xb8, 0xe2, 0x92, 0xa7, 0x2e, 0x29, 0xa0, 0xa0, 0xa8,
	0x6e, 0x3a, 0x9e, 0x48, 0x72, 0x28, 0xd7, 0xac, 0xde, 0xd1, 0x58, 0x57, 0x68, 0xa0, 0x21, 0x69,
	0xfe, 0xc0, 0x6d, 0x0c, 0xb7, 0x28, 0x99, 0x5e, 0x99, 0xd3, 0x94, 0x04, 0x2a, 0x0e, 0x3f, 0x40,
	0x77, 0x68, 0xdc, 0x95, 0xa8, 0x8b, 0xd2, 0xc1, 0xc7, 0xd3, 0x68, 0x59, 0xbc, 0x6f, 0xe4, 0xa2,
	0x60, 0x04, 0x77, 0x5a, 0xb1, 0x40, 0xcf, 0xa8, 0x58, 0xec, 0xa3, 0x22, 0x53, 0x02, 0xa1, 0x88,
	0x45, 0xed, 0xc5, 0xa5, 0xb8, 0x97, 0x92, 0x6e, 0xf5, 0x9f, 0xa0, 0xb2, 0xe1, 0x43, 0xb4, 0x70,
	0xa9, 0xbc, 0x0d, 0x8a, 0x9c, 0x3b, 0xb1, 0xcb, 0xda, 0xbb, 0xe1, 0xd0, 0x3b, 0xa2, 0xc6, 0x49,
	0xd7, 0x93, 0xb4, 0xcf, 0xc6, 0x24, 0x10, 0x86, 0x41, 0xae, 0xa7, 0x95, 0x92, 0x6e, 0xf5, 0x9f,
	0xa0, 0xb2, 0xe1, 0x3f, 0x2d, 0xa0, 0xe5, 0x4b, 0xfd, 0x59, 0x4c, 0x98, 0x8a, 0x4f, 0x5f, 0xdd,
	0x43, 0x5b, 0x6a, 0x63, 0x33, 0x04, 0xc8, 0xce, 0x8d, 0x1b, 0x68, 0x51, 0xdc, 0x11, 0xb1, 0x41,
	0xcb, 0xec, 0xbb, 0xde, 0x49, 0x92, 0x92, 0xb6, 0x4a, 0xbc, 0xcd, 0x0e, 0x80, 0xce, 0x8c, 0xff,
	0x82, 0x66, 0x71, 0x99, 0xb2, 0x5a, 0x64, 0xac, 0xb0, 0x60, 0x66, 0x9c, 0x78, 0x30, 0x5b, 0xaa,
	0x53, 0x92, 0xb8, 0xec, 0x6c, 0x30, 0xbc, 0x00, 0x66, 0xd4, 0xf9, 0x20, 0xd7, 0xff, 0x55, 0xfd,
	0xe2, 0xb4, 0x15, 0x1a, 0x68, 0x48, 0x7a, 0x03, 0xd4, 0xdf, 0x07, 0x7e, 0xd8, 0x74, 0x78, 0x7e,
	0xc3, 0x5b, 0x71, 0xe5, 0x0d, 0x68, 0xe7, 0xa2, 0x60, 0x04, 0x37, 0xde, 0x47, 0x2b, 0x82, 0x42,
	0x13, 0x75, 0xfe, 0x7c, 0xc9, 0x1b, 0x74, 0x65, 0x65, 0xbe, 0x9d, 0xa1, 0xc3, 0x10, 0x07, 0xfe,
	0x43, 0xf6, 0x56, 0x95, 0x6c, 0xf3, 0x3a, 0xdb, 0xe6, 0x4f, 0xc7, 0x8e, 0x19, 0xd3, 0x5d, 0x56,
	0x1f, 0xab, 0x92, 0xed, 0x55, 0x66, 0xa4, 0x66, 0xd2, 0x4a, 0x3a, 0xdf, 0x36, 0x74, 0x33, 0x29,
	0x5b, 0xdf, 0x24, 0x82, 0x46, 0x1b, 0xb1, 0xcf, 0xc3, 0x0a, 0xc2, 0xda, 0x75, 0x95, 0x68, 0xa3,
	0x93, 0x10, 0x20, 0xc5, 0xe0, 0xef, 0xa1, 0xf9, 0x73, 0x33, 0xe9, 0xef, 0x7d, 0x9d, 0x99, 0x8a,
	0xe4, 0xbe, 0xcd, 0x57, 0xcc, 0xb4, 0xb1, 0x77, 0x51, 0xfe, 0x60, 0xe1, 0x54, 0xca, 0x84, 0x3d,
	0x24, 0x4a, 0xdc, 0xac, 0xdf, 0x76, 0x3c, 0x77, 0xac, 0x14, 0xe5, 0x47, 0x15, 0xd2, 0xd9, 0xeb,
	0x5d, 0xfa, 0xde, 0x9b, 0x14, 0x9f, 0x88, 0xe5, 0xdb, 0x24, 0x64, 0x0d, 0xba, 0xe3, 0xbd, 0xde,
	0x9d, 0x8e, 0x10, 0x9d, 0xbe, 0xde, 0x8d, 0x42, 0xc0, 0xc8, 0x65, 0xe1, 0x3f, 0x2f, 0xa0, 0x95,
	0x20, 0x53, 0x83, 0x67, 0x2d, 0xc1, 0xe3, 0x5d, 0xd9, 0x6c, 0x59, 0x5f, 0x79, 0x72, 0xca, 0x50,
	0x60, 0x68, 0x7a, 0xfc, 0x08, 0x19, 0x59, 0x65, 0x17, 0xbd, 0x92, 0xbc, 0xed, 0x78, 0x2e, 0xfd,
	0xe2, 0xf6, 0x08, 0x1c, 0x8c, 0x94, 0x40, 0xd5, 0x36, 0xf0, 0x45, 0x4b, 0xff, 0x9b, 0xba, 0xda,
	0xb6, 0xc4, 0x38, 0x48, 0x84, 0xac, 0x04, 0xbf, 0x35, 0xb2, 0x12, 0xbc, 0x8f, 0x56, 0xa4, 0xca,
	0x25, 0xfd, 0xdd, 0x5b, 0xfa, 0x65, 0xae, 0x64, 0xe8, 0x30, 0xc4, 0x81, 0xff, 0xa6, 0x80, 0x96,
	0x44, 0x95, 0x92, 0xae, 0x34, 0xb4, 0x23, 0x63, 0x9b, 0xdd, 0xe8, 0xb3, 0x57, 0x98, 0x48, 0x97,
	0x41, 0x9b, 0x21, 0x53, 0x85, 0xd4, 0x89, 0x90, 0x59, 0x0e, 0xef, 0xb8, 0x3d, 0x20, 0x36, 0x17,
	0x6a, 0xdc, 0xcd, 0x76, 0xdc, 0x4a, 0x12, 0xa8, 0xb8, 0xcd, 0x3d, 0xb4, 0x96, 0x33, 0xeb, 0x4b,
	0x55, 0x21, 0xff, 0x7b, 0x1a, 0xe5, 0xf4, 0x5c, 0xd3, 0x1c, 0xa3, 0x47, 0xe3, 0x1c, 0xd3, 0x4e,
	0xba, 0xf3, 0x44, 0xb7, 0xac, 0xf4, 0x7f, 0x4d, 0x9d, 0x0c, 0x59, 0x3c, 0xfe, 0x04, 0x2d, 0xf2,
	0x98, 0x2f, 0x11, 0xc0, 0x9f, 0x86, 0x65, 0x51, 0xee, 0x54, 0x25, 0x82, 0x8e, 0xc5, 0x2d, 0xf6,
	0x32, 0x9a, 0xfe, 0x7b, 0x14, 0x35, 0xed, 0x7e, 0x3f, 0x16, 0xe5, 0x4e, 0xd9, 0xab, 0x0d, 0x39,
	0x18, 0xc8, 0xe5, 0xc4, 0x4d, 0xb4, 0xa6, 0xfe, 0xd7, 0x54, 0x22, 0x70, 0x4a, 0xef, 0x4e, 0x6e,
	0x0d, 0x43, 0x20, 0x8f, 0x0f, 0x7f, 0x9a, 0xf4, 0xc6, 0xb3, 0x6f, 0x4e, 0xa4, 0xf1, 0x27, 0xe0,
	0x4c, 0x33, 0xbb, 0x8a, 0x80, 0x1c, 0x2e, 0xfc, 0xb3, 0x02, 0x32, 0xce, 0x47, 0xb4, 0x2d, 0xb3,
	0x00, 0x76, 0x3c, 0xdb, 0x36, 0xaa, 0x23, 0xba, 0xf2, 0x26, 0xbd, 0xe5, 0xa3, 0xa8, 0x30, 0x72,
	0x49, 0xb8, 0x83, 0x96, 0x43, 0x3e, 0xda, 0x8e, 0x43, 0x33, 0x26, 0xdd, 0x81, 0x78, 0x59, 0xfa,
	0x7a, 0xa2, 0x1c, 0xa0, 0x93, 0x6f, 0x87, 0x87, 0x20, 0x2b, 0x82, 0x5a, 0x26, 0x9b, 0xb8, 0xe6,
	0x80, 0x67, 0xd0, 0x3c, 0x1b, 0x4b, 0x54, 0x67, 0x4e, 0xff, 0x37, 0xb6, 0xfd, 0x11, 0x38, 0x18,
	0x29, 0xa1, 0xf4, 0xd3, 0x19, 0x34, 0xd2, 0x84, 0xe3, 0x06, 0x5a, 0xa7, 0xf1, 0xb4, 0x1a, 0x69,
	0xb0, 0x48, 0x84, 0xbf, 0x91, 0xb2, 0x77, 0xf8, 0x46, 0x0e, 0x1d, 0x72, 0xb9, 0xf0, 0x1f, 0x70,
	0x69, 0xbc, 0xd1, 0x9d, 0x1b, 0x07, 0x26, 0x6d, 0xe2, 0xa5, 0xeb, 0xb6, 0x52, 0xcf, 0x1b, 0x39,
	0xf2, 0x20, 0x77, 0x16, 0x1c, 0xa1, 0xd5, 0x73, 0x62, 0xf9, 0x3d, 0x52, 0xed, 0x87, 0x21, 0xf1,
	0xe2, 0xaf, 0x58, 0x32, 0x96, 0x61, 0x60, 0x25, 0x2b, 0x0c, 0x86, 0xe5, 0x63, 0x40, 0x1b, 0x3c,
	0x63, 0x56, 0x4e, 0x86, 0x4d, 0x3c, 0xa5, 0xdf, 0x57, 0xfa, 0x1d, 0xea, 0xe9, 0x30, 0x79, 0xf9,
	0xac, 0x34, 0xb4, 0x4c, 0xfe, 0x31, 0x47, 0x69, 0xaf, 0x90, 0xa1, 0xe5, 0x9e, 0x42, 0x03, 0x0d,
	0xc9, 0xfe, 0x3f, 0x4d, 0xf8, 0x98, 0xbc, 0x96, 0xbe, 0x96, 0x42, 0x03, 0x0d, 0x89, 0xeb, 0x68,
	0x2d, 0x4d, 0xac, 0x52, 0x01, 0xb3, 0x7a, 0x79, 0x25, 0x43, 0x86, 0x3c, 0x1e, 0x6a, 0x6f, 0xd8,
	0x30, 0x37, 0x6b, 0xd4, 0x46, 0x33, 0x51, 0x73, 0xba, 0xbd, 0x69, 0x0c, 0x43, 0x20, 0x8f, 0x0f,
	0xdf, 0x47, 0xab, 0xe9, 0x70, 0xcd, 0xe3, 0x5b, 0x32, 0xaf, 0xf7, 0xf3, 0x37, 0xb2, 0x00, 0x18,
	0xe6, 0xa9, 0xdc, 0x7b, 0xf2, 0xe5, 0xd6, 0x6b, 0x3f, 0xff, 0x72, 0xeb, 0xb5, 0x5f, 0x7c, 0xb9,
	0xf5, 0xda, 0x4f, 0x9e, 0x6e, 0x15, 0x9e, 0x3c, 0xdd, 0x2a, 0xfc, 0xfc, 0xe9, 0x56, 0xe1, 0x17,
	0x4f, 0xb7, 0x0a, 0xff, 0xf5, 0x74, 0xab, 0xf0, 0x67, 0xbf, 0xdc, 0x7a, 0xed, 0x77, 0x26, 0xae,
	0xdf, 0xff, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc5, 0x01, 0xb0, 0xd5, 0x3c, 0x3c, 0x00, 0x00,
}

func (m *AllocatorSyncedStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorSyncedStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocatorSyncedStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.EntityUid)
	copy(dAtA[i:], m.EntityUid)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.EntityUid)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xda
	i -= len(m.StandbyHours)
	copy(dAtA[i:], m.StandbyHours)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.StandbyHours)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd2
	i = encodeVarintGenerated(dAtA, i, uint64(m.DeletionCost))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc8
	i -= len(m.HistoryUnassignedMessage)
	copy(dAtA[i:], m.HistoryUnassignedMessage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.HistoryUnassignedMessage)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	i -= len(m.UnassignedMessage)
	copy(dAtA[i:], m.UnassignedMessage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.UnassignedMessage)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	i = encodeVarintGenerated(dAtA, i, uint64(m.UnassignedReason))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastProcessNotReadytime))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	i -= len(m.WorkerMode)
	copy(dAtA[i:], m.WorkerMode)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.WorkerMode)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	i -= len(m.ResourcePool)
	copy(dAtA[i:], m.ResourcePool)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ResourcePool)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	i--
	if m.EntityAlloced {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i -= len(m.EntityName)
	copy(dAtA[i:], m.EntityName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.EntityName)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	i--
	if m.NamingRegisteredReady {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i--
	if m.ProcessReady {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x78
	i--
	if m.InternalReclaim {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	i--
	if m.Reclaim {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	i -= len(m.PackageStatus)
	copy(dAtA[i:], m.PackageStatus)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PackageStatus)))
	i--
	dAtA[i] = 0x62
	i -= len(m.Phase)
	copy(dAtA[i:], m.Phase)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Phase)))
	i--
	dAtA[i] = 0x5a
	i = encodeVarintGenerated(dAtA, i, uint64(m.ProcessScore))
	i--
	dAtA[i] = 0x50
	i -= len(m.UserDefVersion)
	copy(dAtA[i:], m.UserDefVersion)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.UserDefVersion)))
	i--
	dAtA[i] = 0x4a
	i -= len(m.Version)
	copy(dAtA[i:], m.Version)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Version)))
	i--
	dAtA[i] = 0x42
	i -= len(m.ResVersion)
	copy(dAtA[i:], m.ResVersion)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ResVersion)))
	i--
	dAtA[i] = 0x3a
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastProcessNotMatchtime))
	i--
	dAtA[i] = 0x30
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastResourceNotMatchtime))
	i--
	dAtA[i] = 0x28
	i--
	if m.ProcessMatch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i--
	if m.ResourceMatch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i -= len(m.HostIP)
	copy(dAtA[i:], m.HostIP)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.HostIP)))
	i--
	dAtA[i] = 0x12
	i -= len(m.IP)
	copy(dAtA[i:], m.IP)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.IP)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BackupOfPod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupOfPod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupOfPod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Uid)
	copy(dAtA[i:], m.Uid)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Uid)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BroadcastPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RowComplete != nil {
		i--
		if *m.RowComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.UpdatePlanTimestamp))
	i--
	dAtA[i] = 0x48
	i--
	if m.IsDaemonSet {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.Preload {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	if m.UpdatingGracefully != nil {
		i--
		if *m.UpdatingGracefully {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Online != nil {
		i--
		if *m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	i -= len(m.UserDefVersion)
	copy(dAtA[i:], m.UserDefVersion)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.UserDefVersion)))
	i--
	dAtA[i] = 0x22
	i -= len(m.CompressedCustomInfo)
	copy(dAtA[i:], m.CompressedCustomInfo)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CompressedCustomInfo)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.CustomInfo)
	copy(dAtA[i:], m.CustomInfo)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CustomInfo)))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.WorkerSchedulePlan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BrokenRecoverQuotaConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokenRecoverQuotaConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BrokenRecoverQuotaConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeWindow != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.TimeWindow))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxFailedCount != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.MaxFailedCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.PredictDelaySeconds)
	copy(dAtA[i:], m.PredictDelaySeconds)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PredictDelaySeconds)))
	i--
	dAtA[i] = 0x62
	i -= len(m.MemExtraRatio)
	copy(dAtA[i:], m.MemExtraRatio)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.MemExtraRatio)))
	i--
	dAtA[i] = 0x5a
	i -= len(m.MemExtraBytes)
	copy(dAtA[i:], m.MemExtraBytes)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.MemExtraBytes)))
	i--
	dAtA[i] = 0x52
	i -= len(m.MemForceEmpty)
	copy(dAtA[i:], m.MemForceEmpty)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.MemForceEmpty)))
	i--
	dAtA[i] = 0x4a
	i -= len(m.MemWmarkRatio)
	copy(dAtA[i:], m.MemWmarkRatio)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.MemWmarkRatio)))
	i--
	dAtA[i] = 0x42
	i -= len(m.NoMemcgReclaim)
	copy(dAtA[i:], m.NoMemcgReclaim)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.NoMemcgReclaim)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.NetPriority)
	copy(dAtA[i:], m.NetPriority)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.NetPriority)))
	i--
	dAtA[i] = 0x32
	i -= len(m.CPUllcCache)
	copy(dAtA[i:], m.CPUllcCache)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CPUllcCache)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.CPUBvtWarpNs)
	copy(dAtA[i:], m.CPUBvtWarpNs)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CPUBvtWarpNs)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintGenerated(dAtA, i, uint64(m.StopGracePeriod))
	i--
	dAtA[i] = 0x18
	i = encodeVarintGenerated(dAtA, i, uint64(m.RestartCountLimit))
	i--
	dAtA[i] = 0x10
	if len(m.Ulimits) > 0 {
		for iNdEx := len(m.Ulimits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ulimits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContainerHippoExterned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerHippoExterned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerHippoExterned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Alias)
	copy(dAtA[i:], m.Alias)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Alias)))
	i--
	dAtA[i] = 0x32
	if m.Configs != nil {
		{
			size, err := m.Configs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.HostConfig != nil {
		i -= len(m.HostConfig)
		copy(dAtA[i:], m.HostConfig)
		i = encodeVarintGenerated(dAtA, i, uint64(len(m.HostConfig)))
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.PreDeployImage)
	copy(dAtA[i:], m.PreDeployImage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PreDeployImage)))
	i--
	dAtA[i] = 0x12
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Device) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Device) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.CgroupPermissions)
	copy(dAtA[i:], m.CgroupPermissions)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CgroupPermissions)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.PathInContainer)
	copy(dAtA[i:], m.PathInContainer)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PathInContainer)))
	i--
	dAtA[i] = 0x12
	i -= len(m.PathOnHost)
	copy(dAtA[i:], m.PathOnHost)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PathOnHost)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HealthCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.WorkerStatus)
	copy(dAtA[i:], m.WorkerStatus)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.WorkerStatus)))
	i--
	dAtA[i] = 0x62
	i -= len(m.Version)
	copy(dAtA[i:], m.Version)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Version)))
	i--
	dAtA[i] = 0x5a
	i -= len(m.CompressedMetas)
	copy(dAtA[i:], m.CompressedMetas)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CompressedMetas)))
	i--
	dAtA[i] = 0x52
	i--
	if m.Checked {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	if len(m.Metas) > 0 {
		keysForMetas := make([]string, 0, len(m.Metas))
		for k := range m.Metas {
			keysForMetas = append(keysForMetas, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMetas)
		for iNdEx := len(keysForMetas) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Metas[string(keysForMetas[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForMetas[iNdEx])
			copy(dAtA[i:], keysForMetas[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForMetas[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.LostCount))
	i--
	dAtA[i] = 0x38
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastLostTime))
	i--
	dAtA[i] = 0x30
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x22
	{
		size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HippoContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HippoContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HippoContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ContainerHippoExterned.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Container.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HippoPodSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HippoPodSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HippoPodSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HippoVolumes) > 0 {
		for iNdEx := len(m.HippoVolumes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HippoVolumes[iNdEx])
			copy(dAtA[i:], m.HippoVolumes[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(m.HippoVolumes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.HippoPodSpecExtendFields.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Containers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HippoPodSpecExtendFields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HippoPodSpecExtendFields) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HippoPodSpecExtendFields) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NeedHippoMounts != nil {
		i--
		if *m.NeedHippoMounts {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RestartWithoutRemove != nil {
		i--
		if *m.RestartWithoutRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.PredictDelayTime))
	i--
	dAtA[i] = 0x28
	if len(m.PackageInfos) > 0 {
		for iNdEx := len(m.PackageInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PackageInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= len(m.ContainerModel)
	copy(dAtA[i:], m.ContainerModel)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ContainerModel)))
	i--
	dAtA[i] = 0x1a
	if m.CPUShareNum != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.CPUShareNum))
		i--
		dAtA[i] = 0x10
	}
	i -= len(m.CpusetMode)
	copy(dAtA[i:], m.CpusetMode)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.CpusetMode)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HippoPodTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HippoPodTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HippoPodTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HippoSlotID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HippoSlotID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HippoSlotID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.SlotID))
	i--
	dAtA[i] = 0x10
	i -= len(m.SlaveAddress)
	copy(dAtA[i:], m.SlaveAddress)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.SlaveAddress)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PackageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackageInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PackageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.PackageURI)
	copy(dAtA[i:], m.PackageURI)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PackageURI)))
	i--
	dAtA[i] = 0x12
	i -= len(m.PacakgeType)
	copy(dAtA[i:], m.PacakgeType)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.PacakgeType)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PodStandbyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodStandbyStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodStandbyStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StandbyHours) > 0 {
		for iNdEx := len(m.StandbyHours) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintGenerated(dAtA, i, uint64(m.StandbyHours[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.UseOrder))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ServiceCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Version)
	copy(dAtA[i:], m.Version)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Version)))
	i--
	dAtA[i] = 0x62
	i--
	if m.StartWarmup {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x52
	i = encodeVarintGenerated(dAtA, i, uint64(m.DeleteCount))
	i--
	dAtA[i] = 0x48
	i--
	if m.InWarmup {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x32
	{
		size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	i = encodeVarintGenerated(dAtA, i, uint64(m.Score))
	i--
	dAtA[i] = 0x20
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ServiceName)
	copy(dAtA[i:], m.ServiceName)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ServiceName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SignedVersionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedVersionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedVersionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Cm2TopoInfo)
	copy(dAtA[i:], m.Cm2TopoInfo)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Cm2TopoInfo)))
	i--
	dAtA[i] = 0x32
	if len(m.BufferSelector) > 0 {
		keysForBufferSelector := make([]string, 0, len(m.BufferSelector))
		for k := range m.BufferSelector {
			keysForBufferSelector = append(keysForBufferSelector, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForBufferSelector)
		for iNdEx := len(keysForBufferSelector) - 1; iNdEx >= 0; iNdEx-- {
			v := m.BufferSelector[string(keysForBufferSelector[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForBufferSelector[iNdEx])
			copy(dAtA[i:], keysForBufferSelector[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForBufferSelector[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RestartAfterResourceChange != nil {
		i--
		if *m.RestartAfterResourceChange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	i -= len(m.Signature)
	copy(dAtA[i:], m.Signature)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Signature)))
	i--
	dAtA[i] = 0x1a
	if m.Template != nil {
		{
			size, err := m.Template.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.ShardGroupVersion)
	copy(dAtA[i:], m.ShardGroupVersion)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ShardGroupVersion)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Ulimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ulimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ulimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.Hard))
	i--
	dAtA[i] = 0x18
	i = encodeVarintGenerated(dAtA, i, uint64(m.Soft))
	i--
	dAtA[i] = 0x10
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VersionPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.BroadcastPlan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SignedVersionPlan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WorkerCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Reason)
	copy(dAtA[i:], m.Reason)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Reason)))
	i--
	dAtA[i] = 0x22
	{
		size, err := m.LastTransitionTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i -= len(m.Status)
	copy(dAtA[i:], m.Status)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Status)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WorkerNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WorkerNodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.ListMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.TypeMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WorkerNodeSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsSpot {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x78
	{
		size, err := m.BackupOfPod.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	i -= len(m.StandbyHours)
	copy(dAtA[i:], m.StandbyHours)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.StandbyHours)))
	i--
	dAtA[i] = 0x6a
	i = encodeVarintGenerated(dAtA, i, uint64(m.DeletionCost))
	i--
	dAtA[i] = 0x60
	i -= len(m.ResourcePool)
	copy(dAtA[i:], m.ResourcePool)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ResourcePool)))
	i--
	dAtA[i] = 0x5a
	i = encodeVarintGenerated(dAtA, i, uint64(m.OwnerGeneration))
	i--
	dAtA[i] = 0x50
	i--
	if m.Reclaim {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x48
	i--
	if m.Releasing {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.ToDelete {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	if m.DependencyReady != nil {
		i--
		if *m.DependencyReady {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	i -= len(m.WorkerMode)
	copy(dAtA[i:], m.WorkerMode)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.WorkerMode)))
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.VersionPlan.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	i -= len(m.Version)
	copy(dAtA[i:], m.Version)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Version)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ResVersion)
	copy(dAtA[i:], m.ResVersion)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ResVersion)))
	i--
	dAtA[i] = 0x12
	if m.Selector != nil {
		{
			size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsFedWorker {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x80
	if len(m.RestartRecords) > 0 {
		keysForRestartRecords := make([]string, 0, len(m.RestartRecords))
		for k := range m.RestartRecords {
			keysForRestartRecords = append(keysForRestartRecords, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForRestartRecords)
		for iNdEx := len(keysForRestartRecords) - 1; iNdEx >= 0; iNdEx-- {
			v := m.RestartRecords[string(keysForRestartRecords[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGenerated(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForRestartRecords[iNdEx])
			copy(dAtA[i:], keysForRestartRecords[iNdEx])
			i = encodeVarintGenerated(dAtA, i, uint64(len(keysForRestartRecords[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenerated(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	i -= len(m.BadReasonMessage)
	copy(dAtA[i:], m.BadReasonMessage)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.BadReasonMessage)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf2
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	i--
	if m.PodReady {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe0
	i--
	if m.ServiceInfoMetasRecoverd {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd8
	{
		size, err := m.PodStandbyStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd2
	{
		size, err := m.WorkerStateChangeRecoder.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xca
	{
		size, err := m.SlotID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	i = encodeVarintGenerated(dAtA, i, uint64(m.BadReason))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb8
	i--
	if m.ToRelease {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	i--
	if m.Complete {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	i -= len(m.ServiceInfoMetas)
	copy(dAtA[i:], m.ServiceInfoMetas)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ServiceInfoMetas)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	i--
	if m.ServiceReadyForMinTime {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	i--
	if m.ServiceReady {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	if len(m.ServiceConditions) > 0 {
		for iNdEx := len(m.ServiceConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenerated(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	i -= len(m.ServiceStatus)
	copy(dAtA[i:], m.ServiceStatus)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ServiceStatus)))
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.HealthCondition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	i -= len(m.ProcessStep)
	copy(dAtA[i:], m.ProcessStep)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.ProcessStep)))
	i--
	dAtA[i] = 0x6a
	i -= len(m.HealthStatus)
	copy(dAtA[i:], m.HealthStatus)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.HealthStatus)))
	i--
	dAtA[i] = 0x62
	i -= len(m.AllocStatus)
	copy(dAtA[i:], m.AllocStatus)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.AllocStatus)))
	i--
	dAtA[i] = 0x5a
	i = encodeVarintGenerated(dAtA, i, uint64(m.Score))
	i--
	dAtA[i] = 0x50
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastWorkerNotReadytime))
	i--
	dAtA[i] = 0x48
	i--
	if m.WorkerReady {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.InRestarting {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	i--
	if m.InUpdating {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i--
	if m.NeedWarmup {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	i--
	if m.InWarmup {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i--
	if m.Warmup {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i--
	if m.ServiceOffline {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	{
		size, err := m.AllocatorSyncedStatus.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WorkerSchedulePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerSchedulePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerSchedulePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.DelayDeleteBackupSeconds))
	i--
	dAtA[i] = 0x40
	i -= len(m.RecoverStrategy)
	copy(dAtA[i:], m.RecoverStrategy)
	i = encodeVarintGenerated(dAtA, i, uint64(len(m.RecoverStrategy)))
	i--
	dAtA[i] = 0x3a
	if m.BrokenRecoverQuotaConfig != nil {
		{
			size, err := m.BrokenRecoverQuotaConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGenerated(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintGenerated(dAtA, i, uint64(m.WorkerReadyTimeout))
	i--
	dAtA[i] = 0x28
	i = encodeVarintGenerated(dAtA, i, uint64(m.ProcessMatchTimeout))
	i--
	dAtA[i] = 0x20
	i = encodeVarintGenerated(dAtA, i, uint64(m.ResourceMatchTimeout))
	i--
	dAtA[i] = 0x18
	i = encodeVarintGenerated(dAtA, i, uint64(m.WarmupSeconds))
	i--
	dAtA[i] = 0x10
	i = encodeVarintGenerated(dAtA, i, uint64(m.MinReadySeconds))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *WorkerStateChangeRecoder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerStateChangeRecoder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerStateChangeRecoder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastWarmupEndTime))
	i--
	dAtA[i] = 0x48
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastWarmupStartTime))
	i--
	dAtA[i] = 0x40
	i = encodeVarintGenerated(dAtA, i, uint64(m.WorkerReadyTime))
	i--
	dAtA[i] = 0x38
	i = encodeVarintGenerated(dAtA, i, uint64(m.PodReadyTime))
	i--
	dAtA[i] = 0x30
	i = encodeVarintGenerated(dAtA, i, uint64(m.AssignedTime))
	i--
	dAtA[i] = 0x28
	i = encodeVarintGenerated(dAtA, i, uint64(m.LastDeleteBackupTime))
	i--
	dAtA[i] = 0x20
	{
		size, err := m.BecomeCurrentTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.LastUpdateStatusTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenerated(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.LastServiceReadyTime != nil {
		i = encodeVarintGenerated(dAtA, i, uint64(*m.LastServiceReadyTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenerated(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenerated(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AllocatorSyncedStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IP)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.HostIP)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	n += 2
	n += 1 + sovGenerated(uint64(m.LastResourceNotMatchtime))
	n += 1 + sovGenerated(uint64(m.LastProcessNotMatchtime))
	l = len(m.ResVersion)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Version)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.UserDefVersion)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.ProcessScore))
	l = len(m.Phase)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.PackageStatus)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 3
	l = len(m.EntityName)
	n += 2 + l + sovGenerated(uint64(l))
	n += 3
	l = len(m.ResourcePool)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.WorkerMode)
	n += 2 + l + sovGenerated(uint64(l))
	n += 2 + sovGenerated(uint64(m.LastProcessNotReadytime))
	n += 2 + sovGenerated(uint64(m.UnassignedReason))
	l = len(m.UnassignedMessage)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.HistoryUnassignedMessage)
	n += 2 + l + sovGenerated(uint64(l))
	n += 2 + sovGenerated(uint64(m.DeletionCost))
	l = len(m.StandbyHours)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.EntityUid)
	n += 2 + l + sovGenerated(uint64(l))
	return n
}

func (m *BackupOfPod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Uid)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *BroadcastPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.WorkerSchedulePlan.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.CustomInfo)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.CompressedCustomInfo)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.UserDefVersion)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Online != nil {
		n += 2
	}
	if m.UpdatingGracefully != nil {
		n += 2
	}
	n += 2
	n += 2
	n += 1 + sovGenerated(uint64(m.UpdatePlanTimestamp))
	if m.RowComplete != nil {
		n += 2
	}
	return n
}

func (m *BrokenRecoverQuotaConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxFailedCount != nil {
		n += 1 + sovGenerated(uint64(*m.MaxFailedCount))
	}
	if m.TimeWindow != nil {
		n += 1 + sovGenerated(uint64(*m.TimeWindow))
	}
	return n
}

func (m *ContainerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ulimits) > 0 {
		for _, e := range m.Ulimits {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	n += 1 + sovGenerated(uint64(m.RestartCountLimit))
	n += 1 + sovGenerated(uint64(m.StopGracePeriod))
	l = len(m.CPUBvtWarpNs)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.CPUllcCache)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.NetPriority)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.NoMemcgReclaim)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.MemWmarkRatio)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.MemForceEmpty)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.MemExtraBytes)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.MemExtraRatio)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.PredictDelaySeconds)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *ContainerHippoExterned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	l = len(m.PreDeployImage)
	n += 1 + l + sovGenerated(uint64(l))
	if m.HostConfig != nil {
		l = len(m.HostConfig)
		n += 1 + l + sovGenerated(uint64(l))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	if m.Configs != nil {
		l = m.Configs.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Alias)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Device) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathOnHost)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.PathInContainer)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.CgroupPermissions)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *HealthCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.LastTransitionTime.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.LastLostTime))
	n += 1 + sovGenerated(uint64(m.LostCount))
	if len(m.Metas) > 0 {
		for k, v := range m.Metas {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	n += 2
	l = len(m.CompressedMetas)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Version)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.WorkerStatus)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *HippoContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Container.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ContainerHippoExterned.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *HippoPodSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PodSpec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	l = m.HippoPodSpecExtendFields.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.HippoVolumes) > 0 {
		for _, b := range m.HippoVolumes {
			l = len(b)
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *HippoPodSpecExtendFields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CpusetMode)
	n += 1 + l + sovGenerated(uint64(l))
	if m.CPUShareNum != nil {
		n += 1 + sovGenerated(uint64(*m.CPUShareNum))
	}
	l = len(m.ContainerModel)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.PackageInfos) > 0 {
		for _, e := range m.PackageInfos {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	n += 1 + sovGenerated(uint64(m.PredictDelayTime))
	if m.RestartWithoutRemove != nil {
		n += 2
	}
	if m.NeedHippoMounts != nil {
		n += 2
	}
	return n
}

func (m *HippoPodTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *HippoSlotID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SlaveAddress)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.SlotID))
	return n
}

func (m *PackageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PacakgeType)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.PackageURI)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *PodStandbyStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.UseOrder))
	if len(m.StandbyHours) > 0 {
		for _, e := range m.StandbyHours {
			n += 1 + sovGenerated(uint64(e))
		}
	}
	return n
}

func (m *ServiceCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ServiceName)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Score))
	l = m.LastTransitionTime.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	n += 1 + sovGenerated(uint64(m.DeleteCount))
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	l = len(m.Version)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *SignedVersionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShardGroupVersion)
	n += 1 + l + sovGenerated(uint64(l))
	if m.Template != nil {
		l = m.Template.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.Signature)
	n += 1 + l + sovGenerated(uint64(l))
	if m.RestartAfterResourceChange != nil {
		n += 2
	}
	if len(m.BufferSelector) > 0 {
		for k, v := range m.BufferSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 1 + sovGenerated(uint64(mapEntrySize))
		}
	}
	l = len(m.Cm2TopoInfo)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *Ulimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.Soft))
	n += 1 + sovGenerated(uint64(m.Hard))
	return n
}

func (m *VersionPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SignedVersionPlan.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.BroadcastPlan.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *WorkerCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Status)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.LastTransitionTime.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Reason)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Message)
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *WorkerNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovGenerated(uint64(l))
	return n
}

func (m *WorkerNodeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGenerated(uint64(l))
		}
	}
	return n
}

func (m *WorkerNodeSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.ResVersion)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.Version)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.VersionPlan.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.WorkerMode)
	n += 1 + l + sovGenerated(uint64(l))
	if m.DependencyReady != nil {
		n += 2
	}
	n += 2
	n += 2
	n += 2
	n += 1 + sovGenerated(uint64(m.OwnerGeneration))
	l = len(m.ResourcePool)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.DeletionCost))
	l = len(m.StandbyHours)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.BackupOfPod.Size()
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	return n
}

func (m *WorkerNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AllocatorSyncedStatus.Size()
	n += 1 + l + sovGenerated(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	n += 1 + sovGenerated(uint64(m.LastWorkerNotReadytime))
	n += 1 + sovGenerated(uint64(m.Score))
	l = len(m.AllocStatus)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.HealthStatus)
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ProcessStep)
	n += 1 + l + sovGenerated(uint64(l))
	l = m.HealthCondition.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = len(m.ServiceStatus)
	n += 1 + l + sovGenerated(uint64(l))
	if len(m.ServiceConditions) > 0 {
		for _, e := range m.ServiceConditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	n += 3
	n += 3
	l = len(m.ServiceInfoMetas)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovGenerated(uint64(l))
		}
	}
	n += 3
	n += 3
	n += 2 + sovGenerated(uint64(m.BadReason))
	l = m.SlotID.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.WorkerStateChangeRecoder.Size()
	n += 2 + l + sovGenerated(uint64(l))
	l = m.PodStandbyStatus.Size()
	n += 2 + l + sovGenerated(uint64(l))
	n += 3
	n += 3
	l = len(m.Name)
	n += 2 + l + sovGenerated(uint64(l))
	l = len(m.BadReasonMessage)
	n += 2 + l + sovGenerated(uint64(l))
	if len(m.RestartRecords) > 0 {
		for k, v := range m.RestartRecords {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGenerated(uint64(len(k))) + 1 + len(v) + sovGenerated(uint64(len(v)))
			n += mapEntrySize + 2 + sovGenerated(uint64(mapEntrySize))
		}
	}
	n += 3
	return n
}

func (m *WorkerSchedulePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGenerated(uint64(m.MinReadySeconds))
	n += 1 + sovGenerated(uint64(m.WarmupSeconds))
	n += 1 + sovGenerated(uint64(m.ResourceMatchTimeout))
	n += 1 + sovGenerated(uint64(m.ProcessMatchTimeout))
	n += 1 + sovGenerated(uint64(m.WorkerReadyTimeout))
	if m.BrokenRecoverQuotaConfig != nil {
		l = m.BrokenRecoverQuotaConfig.Size()
		n += 1 + l + sovGenerated(uint64(l))
	}
	l = len(m.RecoverStrategy)
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.DelayDeleteBackupSeconds))
	return n
}

func (m *WorkerStateChangeRecoder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastServiceReadyTime != nil {
		n += 1 + sovGenerated(uint64(*m.LastServiceReadyTime))
	}
	l = m.LastUpdateStatusTime.Size()
	n += 1 + l + sovGenerated(uint64(l))
	l = m.BecomeCurrentTime.Size()
	n += 1 + l + sovGenerated(uint64(l))
	n += 1 + sovGenerated(uint64(m.LastDeleteBackupTime))
	n += 1 + sovGenerated(uint64(m.AssignedTime))
	n += 1 + sovGenerated(uint64(m.PodReadyTime))
	n += 1 + sovGenerated(uint64(m.WorkerReadyTime))
	n += 1 + sovGenerated(uint64(m.LastWarmupStartTime))
	n += 1 + sovGenerated(uint64(m.LastWarmupEndTime))
	return n
}

func sovGenerated(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenerated(x uint64) (n int) {
	return sovGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AllocatorSyncedStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllocatorSyncedStatus{`,
		`IP:` + fmt.Sprintf("%v", this.IP) + `,`,
		`HostIP:` + fmt.Sprintf("%v", this.HostIP) + `,`,
		`ResourceMatch:` + fmt.Sprintf("%v", this.ResourceMatch) + `,`,
		`ProcessMatch:` + fmt.Sprintf("%v", this.ProcessMatch) + `,`,
		`LastResourceNotMatchtime:` + fmt.Sprintf("%v", this.LastResourceNotMatchtime) + `,`,
		`LastProcessNotMatchtime:` + fmt.Sprintf("%v", this.LastProcessNotMatchtime) + `,`,
		`ResVersion:` + fmt.Sprintf("%v", this.ResVersion) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`UserDefVersion:` + fmt.Sprintf("%v", this.UserDefVersion) + `,`,
		`ProcessScore:` + fmt.Sprintf("%v", this.ProcessScore) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`PackageStatus:` + fmt.Sprintf("%v", this.PackageStatus) + `,`,
		`Reclaim:` + fmt.Sprintf("%v", this.Reclaim) + `,`,
		`InternalReclaim:` + fmt.Sprintf("%v", this.InternalReclaim) + `,`,
		`ProcessReady:` + fmt.Sprintf("%v", this.ProcessReady) + `,`,
		`NamingRegisteredReady:` + fmt.Sprintf("%v", this.NamingRegisteredReady) + `,`,
		`EntityName:` + fmt.Sprintf("%v", this.EntityName) + `,`,
		`EntityAlloced:` + fmt.Sprintf("%v", this.EntityAlloced) + `,`,
		`ResourcePool:` + fmt.Sprintf("%v", this.ResourcePool) + `,`,
		`WorkerMode:` + fmt.Sprintf("%v", this.WorkerMode) + `,`,
		`LastProcessNotReadytime:` + fmt.Sprintf("%v", this.LastProcessNotReadytime) + `,`,
		`UnassignedReason:` + fmt.Sprintf("%v", this.UnassignedReason) + `,`,
		`UnassignedMessage:` + fmt.Sprintf("%v", this.UnassignedMessage) + `,`,
		`HistoryUnassignedMessage:` + fmt.Sprintf("%v", this.HistoryUnassignedMessage) + `,`,
		`DeletionCost:` + fmt.Sprintf("%v", this.DeletionCost) + `,`,
		`StandbyHours:` + fmt.Sprintf("%v", this.StandbyHours) + `,`,
		`EntityUid:` + fmt.Sprintf("%v", this.EntityUid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BackupOfPod) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BackupOfPod{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BroadcastPlan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BroadcastPlan{`,
		`WorkerSchedulePlan:` + strings.Replace(strings.Replace(this.WorkerSchedulePlan.String(), "WorkerSchedulePlan", "WorkerSchedulePlan", 1), `&`, ``, 1) + `,`,
		`CustomInfo:` + fmt.Sprintf("%v", this.CustomInfo) + `,`,
		`CompressedCustomInfo:` + fmt.Sprintf("%v", this.CompressedCustomInfo) + `,`,
		`UserDefVersion:` + fmt.Sprintf("%v", this.UserDefVersion) + `,`,
		`Online:` + valueToStringGenerated(this.Online) + `,`,
		`UpdatingGracefully:` + valueToStringGenerated(this.UpdatingGracefully) + `,`,
		`Preload:` + fmt.Sprintf("%v", this.Preload) + `,`,
		`IsDaemonSet:` + fmt.Sprintf("%v", this.IsDaemonSet) + `,`,
		`UpdatePlanTimestamp:` + fmt.Sprintf("%v", this.UpdatePlanTimestamp) + `,`,
		`RowComplete:` + valueToStringGenerated(this.RowComplete) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BrokenRecoverQuotaConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BrokenRecoverQuotaConfig{`,
		`MaxFailedCount:` + valueToStringGenerated(this.MaxFailedCount) + `,`,
		`TimeWindow:` + valueToStringGenerated(this.TimeWindow) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerConfig) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUlimits := "[]Ulimit{"
	for _, f := range this.Ulimits {
		repeatedStringForUlimits += strings.Replace(strings.Replace(f.String(), "Ulimit", "Ulimit", 1), `&`, ``, 1) + ","
	}
	repeatedStringForUlimits += "}"
	s := strings.Join([]string{`&ContainerConfig{`,
		`Ulimits:` + repeatedStringForUlimits + `,`,
		`RestartCountLimit:` + fmt.Sprintf("%v", this.RestartCountLimit) + `,`,
		`StopGracePeriod:` + fmt.Sprintf("%v", this.StopGracePeriod) + `,`,
		`CPUBvtWarpNs:` + fmt.Sprintf("%v", this.CPUBvtWarpNs) + `,`,
		`CPUllcCache:` + fmt.Sprintf("%v", this.CPUllcCache) + `,`,
		`NetPriority:` + fmt.Sprintf("%v", this.NetPriority) + `,`,
		`NoMemcgReclaim:` + fmt.Sprintf("%v", this.NoMemcgReclaim) + `,`,
		`MemWmarkRatio:` + fmt.Sprintf("%v", this.MemWmarkRatio) + `,`,
		`MemForceEmpty:` + fmt.Sprintf("%v", this.MemForceEmpty) + `,`,
		`MemExtraBytes:` + fmt.Sprintf("%v", this.MemExtraBytes) + `,`,
		`MemExtraRatio:` + fmt.Sprintf("%v", this.MemExtraRatio) + `,`,
		`PredictDelaySeconds:` + fmt.Sprintf("%v", this.PredictDelaySeconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerHippoExterned) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDevices := "[]Device{"
	for _, f := range this.Devices {
		repeatedStringForDevices += strings.Replace(strings.Replace(f.String(), "Device", "Device", 1), `&`, ``, 1) + ","
	}
	repeatedStringForDevices += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&ContainerHippoExterned{`,
		`Labels:` + mapStringForLabels + `,`,
		`PreDeployImage:` + fmt.Sprintf("%v", this.PreDeployImage) + `,`,
		`HostConfig:` + valueToStringGenerated(this.HostConfig) + `,`,
		`Devices:` + repeatedStringForDevices + `,`,
		`Configs:` + strings.Replace(this.Configs.String(), "ContainerConfig", "ContainerConfig", 1) + `,`,
		`Alias:` + fmt.Sprintf("%v", this.Alias) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Device) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Device{`,
		`PathOnHost:` + fmt.Sprintf("%v", this.PathOnHost) + `,`,
		`PathInContainer:` + fmt.Sprintf("%v", this.PathInContainer) + `,`,
		`CgroupPermissions:` + fmt.Sprintf("%v", this.CgroupPermissions) + `,`,
		`}`,
	}, "")
	return s
}

//	func (this *HealthCondition) String() string {
//		if this == nil {
//			return "nil"
//		}
//		keysForMetas := make([]string, 0, len(this.Metas))
//		for k := range this.Metas {
//			keysForMetas = append(keysForMetas, k)
//		}
//		github_com_gogo_protobuf_sortkeys.Strings(keysForMetas)
//		mapStringForMetas := "map[string]string{"
//		for _, k := range keysForMetas {
//			mapStringForMetas += fmt.Sprintf("%v: %v,", k, this.Metas[k])
//		}
//		mapStringForMetas += "}"
//		s := strings.Join([]string{`&HealthCondition{`,
//			`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
//			`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
//			`LastTransitionTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1), `&`, ``, 1) + `,`,
//			`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
//			`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
//			`LastLostTime:` + fmt.Sprintf("%v", this.LastLostTime) + `,`,
//			`LostCount:` + fmt.Sprintf("%v", this.LostCount) + `,`,
//			`Metas:` + mapStringForMetas + `,`,
//			`Checked:` + fmt.Sprintf("%v", this.Checked) + `,`,
//			`CompressedMetas:` + fmt.Sprintf("%v", this.CompressedMetas) + `,`,
//			`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
//			`WorkerStatus:` + fmt.Sprintf("%v", this.WorkerStatus) + `,`,
//			`}`,
//		}, "")
//		return s
//	}
func (this *HippoContainer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HippoContainer{`,
		`Container:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Container), "Container", "v11.Container", 1), `&`, ``, 1) + `,`,
		`ContainerHippoExterned:` + strings.Replace(strings.Replace(this.ContainerHippoExterned.String(), "ContainerHippoExterned", "ContainerHippoExterned", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HippoPodSpec) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForContainers := "[]HippoContainer{"
	for _, f := range this.Containers {
		repeatedStringForContainers += strings.Replace(strings.Replace(f.String(), "HippoContainer", "HippoContainer", 1), `&`, ``, 1) + ","
	}
	repeatedStringForContainers += "}"
	s := strings.Join([]string{`&HippoPodSpec{`,
		`PodSpec:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.PodSpec), "PodSpec", "v11.PodSpec", 1), `&`, ``, 1) + `,`,
		`Containers:` + repeatedStringForContainers + `,`,
		`HippoPodSpecExtendFields:` + strings.Replace(strings.Replace(this.HippoPodSpecExtendFields.String(), "HippoPodSpecExtendFields", "HippoPodSpecExtendFields", 1), `&`, ``, 1) + `,`,
		`HippoVolumes:` + fmt.Sprintf("%v", this.HippoVolumes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HippoPodSpecExtendFields) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPackageInfos := "[]PackageInfo{"
	for _, f := range this.PackageInfos {
		repeatedStringForPackageInfos += strings.Replace(strings.Replace(f.String(), "PackageInfo", "PackageInfo", 1), `&`, ``, 1) + ","
	}
	repeatedStringForPackageInfos += "}"
	s := strings.Join([]string{`&HippoPodSpecExtendFields{`,
		`CpusetMode:` + fmt.Sprintf("%v", this.CpusetMode) + `,`,
		`CPUShareNum:` + valueToStringGenerated(this.CPUShareNum) + `,`,
		`ContainerModel:` + fmt.Sprintf("%v", this.ContainerModel) + `,`,
		`PackageInfos:` + repeatedStringForPackageInfos + `,`,
		`PredictDelayTime:` + fmt.Sprintf("%v", this.PredictDelayTime) + `,`,
		`RestartWithoutRemove:` + valueToStringGenerated(this.RestartWithoutRemove) + `,`,
		`NeedHippoMounts:` + valueToStringGenerated(this.NeedHippoMounts) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HippoPodTemplate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HippoPodTemplate{`,
		`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
		`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "HippoPodSpec", "HippoPodSpec", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HippoSlotID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HippoSlotID{`,
		`SlaveAddress:` + fmt.Sprintf("%v", this.SlaveAddress) + `,`,
		`SlotID:` + fmt.Sprintf("%v", this.SlotID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PackageInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PackageInfo{`,
		`PacakgeType:` + fmt.Sprintf("%v", this.PacakgeType) + `,`,
		`PackageURI:` + fmt.Sprintf("%v", this.PackageURI) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodStandbyStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodStandbyStatus{`,
		`UseOrder:` + fmt.Sprintf("%v", this.UseOrder) + `,`,
		`StandbyHours:` + fmt.Sprintf("%v", this.StandbyHours) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`LastTransitionTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1), `&`, ``, 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`InWarmup:` + fmt.Sprintf("%v", this.InWarmup) + `,`,
		`DeleteCount:` + fmt.Sprintf("%v", this.DeleteCount) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`StartWarmup:` + fmt.Sprintf("%v", this.StartWarmup) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedVersionPlan) String() string {
	if this == nil {
		return "nil"
	}
	keysForBufferSelector := make([]string, 0, len(this.BufferSelector))
	for k := range this.BufferSelector {
		keysForBufferSelector = append(keysForBufferSelector, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForBufferSelector)
	mapStringForBufferSelector := "map[string]string{"
	for _, k := range keysForBufferSelector {
		mapStringForBufferSelector += fmt.Sprintf("%v: %v,", k, this.BufferSelector[k])
	}
	mapStringForBufferSelector += "}"
	s := strings.Join([]string{`&SignedVersionPlan{`,
		`ShardGroupVersion:` + fmt.Sprintf("%v", this.ShardGroupVersion) + `,`,
		`Template:` + strings.Replace(this.Template.String(), "HippoPodTemplate", "HippoPodTemplate", 1) + `,`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`RestartAfterResourceChange:` + valueToStringGenerated(this.RestartAfterResourceChange) + `,`,
		`BufferSelector:` + mapStringForBufferSelector + `,`,
		`Cm2TopoInfo:` + fmt.Sprintf("%v", this.Cm2TopoInfo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Ulimit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ulimit{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Soft:` + fmt.Sprintf("%v", this.Soft) + `,`,
		`Hard:` + fmt.Sprintf("%v", this.Hard) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VersionPlan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VersionPlan{`,
		`SignedVersionPlan:` + strings.Replace(strings.Replace(this.SignedVersionPlan.String(), "SignedVersionPlan", "SignedVersionPlan", 1), `&`, ``, 1) + `,`,
		`BroadcastPlan:` + strings.Replace(strings.Replace(this.BroadcastPlan.String(), "BroadcastPlan", "BroadcastPlan", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkerCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WorkerCondition{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`LastTransitionTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastTransitionTime), "Time", "v1.Time", 1), `&`, ``, 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}

//	func (this *WorkerNode) String() string {
//		if this == nil {
//			return "nil"
//		}
//		s := strings.Join([]string{`&WorkerNode{`,
//			`TypeMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TypeMeta), "TypeMeta", "v1.TypeMeta", 1), `&`, ``, 1) + `,`,
//			`ObjectMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ObjectMeta), "ObjectMeta", "v1.ObjectMeta", 1), `&`, ``, 1) + `,`,
//			`Spec:` + strings.Replace(strings.Replace(this.Spec.String(), "WorkerNodeSpec", "WorkerNodeSpec", 1), `&`, ``, 1) + `,`,
//			`Status:` + strings.Replace(strings.Replace(this.Status.String(), "WorkerNodeStatus", "WorkerNodeStatus", 1), `&`, ``, 1) + `,`,
//			`}`,
//		}, "")
//		return s
//	}
func (this *WorkerNodeList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]WorkerNode{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(strings.Replace(f.String(), "WorkerNode", "WorkerNode", 1), `&`, ``, 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&WorkerNodeList{`,
		`TypeMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TypeMeta), "TypeMeta", "v1.TypeMeta", 1), `&`, ``, 1) + `,`,
		`ListMeta:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.ListMeta), "ListMeta", "v1.ListMeta", 1), `&`, ``, 1) + `,`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkerNodeSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WorkerNodeSpec{`,
		`Selector:` + strings.Replace(fmt.Sprintf("%v", this.Selector), "LabelSelector", "v1.LabelSelector", 1) + `,`,
		`ResVersion:` + fmt.Sprintf("%v", this.ResVersion) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`VersionPlan:` + strings.Replace(strings.Replace(this.VersionPlan.String(), "VersionPlan", "VersionPlan", 1), `&`, ``, 1) + `,`,
		`WorkerMode:` + fmt.Sprintf("%v", this.WorkerMode) + `,`,
		`DependencyReady:` + valueToStringGenerated(this.DependencyReady) + `,`,
		`ToDelete:` + fmt.Sprintf("%v", this.ToDelete) + `,`,
		`Releasing:` + fmt.Sprintf("%v", this.Releasing) + `,`,
		`Reclaim:` + fmt.Sprintf("%v", this.Reclaim) + `,`,
		`OwnerGeneration:` + fmt.Sprintf("%v", this.OwnerGeneration) + `,`,
		`ResourcePool:` + fmt.Sprintf("%v", this.ResourcePool) + `,`,
		`DeletionCost:` + fmt.Sprintf("%v", this.DeletionCost) + `,`,
		`StandbyHours:` + fmt.Sprintf("%v", this.StandbyHours) + `,`,
		`BackupOfPod:` + strings.Replace(strings.Replace(this.BackupOfPod.String(), "BackupOfPod", "BackupOfPod", 1), `&`, ``, 1) + `,`,
		`IsSpot:` + fmt.Sprintf("%v", this.IsSpot) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkerNodeStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForServiceConditions := "[]ServiceCondition{"
	for _, f := range this.ServiceConditions {
		repeatedStringForServiceConditions += strings.Replace(strings.Replace(f.String(), "ServiceCondition", "ServiceCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForServiceConditions += "}"
	repeatedStringForConditions := "[]WorkerCondition{"
	for _, f := range this.Conditions {
		repeatedStringForConditions += strings.Replace(strings.Replace(f.String(), "WorkerCondition", "WorkerCondition", 1), `&`, ``, 1) + ","
	}
	repeatedStringForConditions += "}"
	keysForRestartRecords := make([]string, 0, len(this.RestartRecords))
	for k := range this.RestartRecords {
		keysForRestartRecords = append(keysForRestartRecords, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRestartRecords)
	mapStringForRestartRecords := "map[string]string{"
	for _, k := range keysForRestartRecords {
		mapStringForRestartRecords += fmt.Sprintf("%v: %v,", k, this.RestartRecords[k])
	}
	mapStringForRestartRecords += "}"
	s := strings.Join([]string{`&WorkerNodeStatus{`,
		`AllocatorSyncedStatus:` + strings.Replace(strings.Replace(this.AllocatorSyncedStatus.String(), "AllocatorSyncedStatus", "AllocatorSyncedStatus", 1), `&`, ``, 1) + `,`,
		`ServiceOffline:` + fmt.Sprintf("%v", this.ServiceOffline) + `,`,
		`Warmup:` + fmt.Sprintf("%v", this.Warmup) + `,`,
		`InWarmup:` + fmt.Sprintf("%v", this.InWarmup) + `,`,
		`NeedWarmup:` + fmt.Sprintf("%v", this.NeedWarmup) + `,`,
		`InUpdating:` + fmt.Sprintf("%v", this.InUpdating) + `,`,
		`InRestarting:` + fmt.Sprintf("%v", this.InRestarting) + `,`,
		`WorkerReady:` + fmt.Sprintf("%v", this.WorkerReady) + `,`,
		`LastWorkerNotReadytime:` + fmt.Sprintf("%v", this.LastWorkerNotReadytime) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`AllocStatus:` + fmt.Sprintf("%v", this.AllocStatus) + `,`,
		`HealthStatus:` + fmt.Sprintf("%v", this.HealthStatus) + `,`,
		`ProcessStep:` + fmt.Sprintf("%v", this.ProcessStep) + `,`,
		`HealthCondition:` + strings.Replace(strings.Replace(this.HealthCondition.String(), "HealthCondition", "HealthCondition", 1), `&`, ``, 1) + `,`,
		`ServiceStatus:` + fmt.Sprintf("%v", this.ServiceStatus) + `,`,
		`ServiceConditions:` + repeatedStringForServiceConditions + `,`,
		`ServiceReady:` + fmt.Sprintf("%v", this.ServiceReady) + `,`,
		`ServiceReadyForMinTime:` + fmt.Sprintf("%v", this.ServiceReadyForMinTime) + `,`,
		`ServiceInfoMetas:` + fmt.Sprintf("%v", this.ServiceInfoMetas) + `,`,
		`Conditions:` + repeatedStringForConditions + `,`,
		`Complete:` + fmt.Sprintf("%v", this.Complete) + `,`,
		`ToRelease:` + fmt.Sprintf("%v", this.ToRelease) + `,`,
		`BadReason:` + fmt.Sprintf("%v", this.BadReason) + `,`,
		`SlotID:` + strings.Replace(strings.Replace(this.SlotID.String(), "HippoSlotID", "HippoSlotID", 1), `&`, ``, 1) + `,`,
		`WorkerStateChangeRecoder:` + strings.Replace(strings.Replace(this.WorkerStateChangeRecoder.String(), "WorkerStateChangeRecoder", "WorkerStateChangeRecoder", 1), `&`, ``, 1) + `,`,
		`PodStandbyStatus:` + strings.Replace(strings.Replace(this.PodStandbyStatus.String(), "PodStandbyStatus", "PodStandbyStatus", 1), `&`, ``, 1) + `,`,
		`ServiceInfoMetasRecoverd:` + fmt.Sprintf("%v", this.ServiceInfoMetasRecoverd) + `,`,
		`PodReady:` + fmt.Sprintf("%v", this.PodReady) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`BadReasonMessage:` + fmt.Sprintf("%v", this.BadReasonMessage) + `,`,
		`RestartRecords:` + mapStringForRestartRecords + `,`,
		`IsFedWorker:` + fmt.Sprintf("%v", this.IsFedWorker) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkerSchedulePlan) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WorkerSchedulePlan{`,
		`MinReadySeconds:` + fmt.Sprintf("%v", this.MinReadySeconds) + `,`,
		`WarmupSeconds:` + fmt.Sprintf("%v", this.WarmupSeconds) + `,`,
		`ResourceMatchTimeout:` + fmt.Sprintf("%v", this.ResourceMatchTimeout) + `,`,
		`ProcessMatchTimeout:` + fmt.Sprintf("%v", this.ProcessMatchTimeout) + `,`,
		`WorkerReadyTimeout:` + fmt.Sprintf("%v", this.WorkerReadyTimeout) + `,`,
		`BrokenRecoverQuotaConfig:` + strings.Replace(this.BrokenRecoverQuotaConfig.String(), "BrokenRecoverQuotaConfig", "BrokenRecoverQuotaConfig", 1) + `,`,
		`RecoverStrategy:` + fmt.Sprintf("%v", this.RecoverStrategy) + `,`,
		`DelayDeleteBackupSeconds:` + fmt.Sprintf("%v", this.DelayDeleteBackupSeconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WorkerStateChangeRecoder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WorkerStateChangeRecoder{`,
		`LastServiceReadyTime:` + valueToStringGenerated(this.LastServiceReadyTime) + `,`,
		`LastUpdateStatusTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.LastUpdateStatusTime), "Time", "v1.Time", 1), `&`, ``, 1) + `,`,
		`BecomeCurrentTime:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.BecomeCurrentTime), "Time", "v1.Time", 1), `&`, ``, 1) + `,`,
		`LastDeleteBackupTime:` + fmt.Sprintf("%v", this.LastDeleteBackupTime) + `,`,
		`AssignedTime:` + fmt.Sprintf("%v", this.AssignedTime) + `,`,
		`PodReadyTime:` + fmt.Sprintf("%v", this.PodReadyTime) + `,`,
		`WorkerReadyTime:` + fmt.Sprintf("%v", this.WorkerReadyTime) + `,`,
		`LastWarmupStartTime:` + fmt.Sprintf("%v", this.LastWarmupStartTime) + `,`,
		`LastWarmupEndTime:` + fmt.Sprintf("%v", this.LastWarmupEndTime) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGenerated(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AllocatorSyncedStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorSyncedStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorSyncedStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResourceMatch = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProcessMatch = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResourceNotMatchtime", wireType)
			}
			m.LastResourceNotMatchtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastResourceNotMatchtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProcessNotMatchtime", wireType)
			}
			m.LastProcessNotMatchtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastProcessNotMatchtime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDefVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessScore", wireType)
			}
			m.ProcessScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = WorkerPhase(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reclaim", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reclaim = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalReclaim", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalReclaim = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProcessReady = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamingRegisteredReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NamingRegisteredReady = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityAlloced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntityAlloced = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerMode = WorkerModeType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProcessNotReadytime", wireType)
			}
			m.LastProcessNotReadytime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastProcessNotReadytime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnassignedReason", wireType)
			}
			m.UnassignedReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnassignedReason |= UnassignedReasonType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnassignedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnassignedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryUnassignedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryUnassignedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionCost", wireType)
			}
			m.DeletionCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionCost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandbyHours", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandbyHours = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupOfPod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupOfPod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupOfPod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerSchedulePlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WorkerSchedulePlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedCustomInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompressedCustomInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDefVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Online = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatingGracefully", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UpdatingGracefully = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preload", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Preload = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDaemonSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDaemonSet = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePlanTimestamp", wireType)
			}
			m.UpdatePlanTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatePlanTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RowComplete = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokenRecoverQuotaConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokenRecoverQuotaConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokenRecoverQuotaConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFailedCount", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxFailedCount = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeWindow", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeWindow = &v
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ulimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ulimits = append(m.Ulimits, Ulimit{})
			if err := m.Ulimits[len(m.Ulimits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartCountLimit", wireType)
			}
			m.RestartCountLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartCountLimit |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopGracePeriod", wireType)
			}
			m.StopGracePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopGracePeriod |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUBvtWarpNs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CPUBvtWarpNs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUllcCache", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CPUllcCache = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetPriority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetPriority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoMemcgReclaim", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoMemcgReclaim = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemWmarkRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemWmarkRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemForceEmpty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemForceEmpty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemExtraBytes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemExtraBytes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemExtraRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemExtraRatio = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictDelaySeconds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredictDelaySeconds = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerHippoExterned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerHippoExterned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerHippoExterned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreDeployImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreDeployImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostConfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostConfig = append(m.HostConfig[:0], dAtA[iNdEx:postIndex]...)
			if m.HostConfig == nil {
				m.HostConfig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, Device{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configs == nil {
				m.Configs = &ContainerConfig{}
			}
			if err := m.Configs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathOnHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathOnHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathInContainer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathInContainer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgroupPermissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgroupPermissions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = HealthConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = HealthStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLostTime", wireType)
			}
			m.LastLostTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLostTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LostCount", wireType)
			}
			m.LostCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LostCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metas == nil {
				m.Metas = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metas[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedMetas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompressedMetas = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerStatus = WorkerType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HippoContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HippoContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HippoContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Container.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHippoExterned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerHippoExterned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HippoPodSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HippoPodSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HippoPodSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PodSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, HippoContainer{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HippoPodSpecExtendFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HippoPodSpecExtendFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HippoVolumes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HippoVolumes = append(m.HippoVolumes, make([]byte, postIndex-iNdEx))
			copy(m.HippoVolumes[len(m.HippoVolumes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HippoPodSpecExtendFields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HippoPodSpecExtendFields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HippoPodSpecExtendFields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpusetMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpusetMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUShareNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CPUShareNum = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageInfos = append(m.PackageInfos, PackageInfo{})
			if err := m.PackageInfos[len(m.PackageInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictDelayTime", wireType)
			}
			m.PredictDelayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredictDelayTime |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartWithoutRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RestartWithoutRemove = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedHippoMounts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NeedHippoMounts = &b
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HippoPodTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HippoPodTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HippoPodTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HippoSlotID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HippoSlotID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HippoSlotID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlaveAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlaveAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotID", wireType)
			}
			m.SlotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlotID |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PackageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacakgeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PacakgeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodStandbyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodStandbyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodStandbyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseOrder", wireType)
			}
			m.UseOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseOrder |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StandbyHours = append(m.StandbyHours, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGenerated
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGenerated
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StandbyHours) == 0 {
					m.StandbyHours = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StandbyHours = append(m.StandbyHours, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StandbyHours", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = RegistryType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InWarmup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InWarmup = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteCount", wireType)
			}
			m.DeleteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteCount |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartWarmup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartWarmup = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedVersionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedVersionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedVersionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardGroupVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardGroupVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Template == nil {
				m.Template = &HippoPodTemplate{}
			}
			if err := m.Template.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartAfterResourceChange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RestartAfterResourceChange = &b
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BufferSelector == nil {
				m.BufferSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BufferSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cm2TopoInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cm2TopoInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ulimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ulimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ulimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Soft", wireType)
			}
			m.Soft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Soft |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hard", wireType)
			}
			m.Hard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hard |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedVersionPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SignedVersionPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BroadcastPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = WorkerConditionType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = k8s_io_api_core_v1.ConditionStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastTransitionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, WorkerNode{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v1.LabelSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionPlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VersionPlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerMode = WorkerModeType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DependencyReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DependencyReady = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToDelete = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Releasing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Releasing = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reclaim", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reclaim = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerGeneration", wireType)
			}
			m.OwnerGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerGeneration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionCost", wireType)
			}
			m.DeletionCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionCost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandbyHours", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StandbyHours = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupOfPod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackupOfPod.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSpot = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatorSyncedStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocatorSyncedStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceOffline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceOffline = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warmup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Warmup = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InWarmup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InWarmup = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedWarmup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedWarmup = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUpdating", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InUpdating = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRestarting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InRestarting = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WorkerReady = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWorkerNotReadytime", wireType)
			}
			m.LastWorkerNotReadytime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastWorkerNotReadytime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocStatus = AllocStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HealthStatus = HealthStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessStep = ProcessStep(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HealthCondition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceStatus = ServiceStatus(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceConditions = append(m.ServiceConditions, ServiceCondition{})
			if err := m.ServiceConditions[len(m.ServiceConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceReady = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceReadyForMinTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceReadyForMinTime = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfoMetas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceInfoMetas = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, WorkerCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Complete = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRelease", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ToRelease = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadReason", wireType)
			}
			m.BadReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadReason |= BadReasonType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SlotID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerStateChangeRecoder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WorkerStateChangeRecoder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodStandbyStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PodStandbyStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInfoMetasRecoverd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ServiceInfoMetasRecoverd = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodReady", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PodReady = bool(v != 0)
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadReasonMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadReasonMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RestartRecords == nil {
				m.RestartRecords = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenerated
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenerated
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGenerated
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenerated(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenerated
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RestartRecords[mapkey] = mapvalue
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFedWorker", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFedWorker = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerSchedulePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerSchedulePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerSchedulePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinReadySeconds", wireType)
			}
			m.MinReadySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinReadySeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarmupSeconds", wireType)
			}
			m.WarmupSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarmupSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMatchTimeout", wireType)
			}
			m.ResourceMatchTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceMatchTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessMatchTimeout", wireType)
			}
			m.ProcessMatchTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessMatchTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerReadyTimeout", wireType)
			}
			m.WorkerReadyTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerReadyTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokenRecoverQuotaConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BrokenRecoverQuotaConfig == nil {
				m.BrokenRecoverQuotaConfig = &BrokenRecoverQuotaConfig{}
			}
			if err := m.BrokenRecoverQuotaConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoverStrategy = RecoverStrategy(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayDeleteBackupSeconds", wireType)
			}
			m.DelayDeleteBackupSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayDeleteBackupSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerStateChangeRecoder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerStateChangeRecoder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerStateChangeRecoder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastServiceReadyTime", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastServiceReadyTime = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateStatusTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastUpdateStatusTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BecomeCurrentTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BecomeCurrentTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDeleteBackupTime", wireType)
			}
			m.LastDeleteBackupTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDeleteBackupTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedTime", wireType)
			}
			m.AssignedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodReadyTime", wireType)
			}
			m.PodReadyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodReadyTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerReadyTime", wireType)
			}
			m.WorkerReadyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkerReadyTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarmupStartTime", wireType)
			}
			m.LastWarmupStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastWarmupStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarmupEndTime", wireType)
			}
			m.LastWarmupEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastWarmupEndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenerated
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenerated
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenerated
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenerated        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenerated          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenerated = fmt.Errorf("proto: unexpected end of group")
)
